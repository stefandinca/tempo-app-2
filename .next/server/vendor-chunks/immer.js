"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/immer";
exports.ids = ["vendor-chunks/immer"];
exports.modules = {

/***/ "(ssr)/./node_modules/immer/dist/immer.mjs":
/*!*******************************************!*\
  !*** ./node_modules/immer/dist/immer.mjs ***!
  \*******************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Immer: () => (/* binding */ Immer2),\n/* harmony export */   applyPatches: () => (/* binding */ applyPatches),\n/* harmony export */   castDraft: () => (/* binding */ castDraft),\n/* harmony export */   castImmutable: () => (/* binding */ castImmutable),\n/* harmony export */   createDraft: () => (/* binding */ createDraft),\n/* harmony export */   current: () => (/* binding */ current),\n/* harmony export */   enableMapSet: () => (/* binding */ enableMapSet),\n/* harmony export */   enablePatches: () => (/* binding */ enablePatches),\n/* harmony export */   finishDraft: () => (/* binding */ finishDraft),\n/* harmony export */   freeze: () => (/* binding */ freeze),\n/* harmony export */   immerable: () => (/* binding */ DRAFTABLE),\n/* harmony export */   isDraft: () => (/* binding */ isDraft),\n/* harmony export */   isDraftable: () => (/* binding */ isDraftable),\n/* harmony export */   nothing: () => (/* binding */ NOTHING),\n/* harmony export */   original: () => (/* binding */ original),\n/* harmony export */   produce: () => (/* binding */ produce),\n/* harmony export */   produceWithPatches: () => (/* binding */ produceWithPatches),\n/* harmony export */   setAutoFreeze: () => (/* binding */ setAutoFreeze),\n/* harmony export */   setUseStrictIteration: () => (/* binding */ setUseStrictIteration),\n/* harmony export */   setUseStrictShallowCopy: () => (/* binding */ setUseStrictShallowCopy)\n/* harmony export */ });\n// src/utils/env.ts\nvar NOTHING = Symbol.for(\"immer-nothing\");\nvar DRAFTABLE = Symbol.for(\"immer-draftable\");\nvar DRAFT_STATE = Symbol.for(\"immer-state\");\n// src/utils/errors.ts\nvar errors =  true ? [\n    // All error codes, starting by 0:\n    function(plugin) {\n        return `The plugin for '${plugin}' has not been loaded into Immer. To enable the plugin, import and call \\`enable${plugin}()\\` when initializing your application.`;\n    },\n    function(thing) {\n        return `produce can only be called on things that are draftable: plain objects, arrays, Map, Set or classes that are marked with '[immerable]: true'. Got '${thing}'`;\n    },\n    \"This object has been frozen and should not be mutated\",\n    function(data) {\n        return \"Cannot use a proxy that has been revoked. Did you pass an object from inside an immer function to an async process? \" + data;\n    },\n    \"An immer producer returned a new value *and* modified its draft. Either return a new value *or* modify the draft.\",\n    \"Immer forbids circular references\",\n    \"The first or second argument to `produce` must be a function\",\n    \"The third argument to `produce` must be a function or undefined\",\n    \"First argument to `createDraft` must be a plain object, an array, or an immerable object\",\n    \"First argument to `finishDraft` must be a draft returned by `createDraft`\",\n    function(thing) {\n        return `'current' expects a draft, got: ${thing}`;\n    },\n    \"Object.defineProperty() cannot be used on an Immer draft\",\n    \"Object.setPrototypeOf() cannot be used on an Immer draft\",\n    \"Immer only supports deleting array indices\",\n    \"Immer only supports setting array indices and the 'length' property\",\n    function(thing) {\n        return `'original' expects a draft, got: ${thing}`;\n    }\n] : 0;\nfunction die(error, ...args) {\n    if (true) {\n        const e = errors[error];\n        const msg = typeof e === \"function\" ? e.apply(null, args) : e;\n        throw new Error(`[Immer] ${msg}`);\n    }\n    throw new Error(`[Immer] minified error nr: ${error}. Full error at: https://bit.ly/3cXEKWf`);\n}\n// src/utils/common.ts\nvar getPrototypeOf = Object.getPrototypeOf;\nfunction isDraft(value) {\n    return !!value && !!value[DRAFT_STATE];\n}\nfunction isDraftable(value) {\n    if (!value) return false;\n    return isPlainObject(value) || Array.isArray(value) || !!value[DRAFTABLE] || !!value.constructor?.[DRAFTABLE] || isMap(value) || isSet(value);\n}\nvar objectCtorString = Object.prototype.constructor.toString();\nvar cachedCtorStrings = /* @__PURE__ */ new WeakMap();\nfunction isPlainObject(value) {\n    if (!value || typeof value !== \"object\") return false;\n    const proto = Object.getPrototypeOf(value);\n    if (proto === null || proto === Object.prototype) return true;\n    const Ctor = Object.hasOwnProperty.call(proto, \"constructor\") && proto.constructor;\n    if (Ctor === Object) return true;\n    if (typeof Ctor !== \"function\") return false;\n    let ctorString = cachedCtorStrings.get(Ctor);\n    if (ctorString === void 0) {\n        ctorString = Function.toString.call(Ctor);\n        cachedCtorStrings.set(Ctor, ctorString);\n    }\n    return ctorString === objectCtorString;\n}\nfunction original(value) {\n    if (!isDraft(value)) die(15, value);\n    return value[DRAFT_STATE].base_;\n}\nfunction each(obj, iter, strict = true) {\n    if (getArchtype(obj) === 0 /* Object */ ) {\n        const keys = strict ? Reflect.ownKeys(obj) : Object.keys(obj);\n        keys.forEach((key)=>{\n            iter(key, obj[key], obj);\n        });\n    } else {\n        obj.forEach((entry, index)=>iter(index, entry, obj));\n    }\n}\nfunction getArchtype(thing) {\n    const state = thing[DRAFT_STATE];\n    return state ? state.type_ : Array.isArray(thing) ? 1 /* Array */  : isMap(thing) ? 2 /* Map */  : isSet(thing) ? 3 /* Set */  : 0 /* Object */ ;\n}\nfunction has(thing, prop) {\n    return getArchtype(thing) === 2 /* Map */  ? thing.has(prop) : Object.prototype.hasOwnProperty.call(thing, prop);\n}\nfunction get(thing, prop) {\n    return getArchtype(thing) === 2 /* Map */  ? thing.get(prop) : thing[prop];\n}\nfunction set(thing, propOrOldValue, value) {\n    const t = getArchtype(thing);\n    if (t === 2 /* Map */ ) thing.set(propOrOldValue, value);\n    else if (t === 3 /* Set */ ) {\n        thing.add(value);\n    } else thing[propOrOldValue] = value;\n}\nfunction is(x, y) {\n    if (x === y) {\n        return x !== 0 || 1 / x === 1 / y;\n    } else {\n        return x !== x && y !== y;\n    }\n}\nfunction isMap(target) {\n    return target instanceof Map;\n}\nfunction isSet(target) {\n    return target instanceof Set;\n}\nfunction latest(state) {\n    return state.copy_ || state.base_;\n}\nfunction shallowCopy(base, strict) {\n    if (isMap(base)) {\n        return new Map(base);\n    }\n    if (isSet(base)) {\n        return new Set(base);\n    }\n    if (Array.isArray(base)) return Array.prototype.slice.call(base);\n    const isPlain = isPlainObject(base);\n    if (strict === true || strict === \"class_only\" && !isPlain) {\n        const descriptors = Object.getOwnPropertyDescriptors(base);\n        delete descriptors[DRAFT_STATE];\n        let keys = Reflect.ownKeys(descriptors);\n        for(let i = 0; i < keys.length; i++){\n            const key = keys[i];\n            const desc = descriptors[key];\n            if (desc.writable === false) {\n                desc.writable = true;\n                desc.configurable = true;\n            }\n            if (desc.get || desc.set) descriptors[key] = {\n                configurable: true,\n                writable: true,\n                // could live with !!desc.set as well here...\n                enumerable: desc.enumerable,\n                value: base[key]\n            };\n        }\n        return Object.create(getPrototypeOf(base), descriptors);\n    } else {\n        const proto = getPrototypeOf(base);\n        if (proto !== null && isPlain) {\n            return {\n                ...base\n            };\n        }\n        const obj = Object.create(proto);\n        return Object.assign(obj, base);\n    }\n}\nfunction freeze(obj, deep = false) {\n    if (isFrozen(obj) || isDraft(obj) || !isDraftable(obj)) return obj;\n    if (getArchtype(obj) > 1) {\n        Object.defineProperties(obj, {\n            set: dontMutateMethodOverride,\n            add: dontMutateMethodOverride,\n            clear: dontMutateMethodOverride,\n            delete: dontMutateMethodOverride\n        });\n    }\n    Object.freeze(obj);\n    if (deep) Object.values(obj).forEach((value)=>freeze(value, true));\n    return obj;\n}\nfunction dontMutateFrozenCollections() {\n    die(2);\n}\nvar dontMutateMethodOverride = {\n    value: dontMutateFrozenCollections\n};\nfunction isFrozen(obj) {\n    if (obj === null || typeof obj !== \"object\") return true;\n    return Object.isFrozen(obj);\n}\n// src/utils/plugins.ts\nvar plugins = {};\nfunction getPlugin(pluginKey) {\n    const plugin = plugins[pluginKey];\n    if (!plugin) {\n        die(0, pluginKey);\n    }\n    return plugin;\n}\nfunction loadPlugin(pluginKey, implementation) {\n    if (!plugins[pluginKey]) plugins[pluginKey] = implementation;\n}\n// src/core/scope.ts\nvar currentScope;\nfunction getCurrentScope() {\n    return currentScope;\n}\nfunction createScope(parent_, immer_) {\n    return {\n        drafts_: [],\n        parent_,\n        immer_,\n        // Whenever the modified draft contains a draft from another scope, we\n        // need to prevent auto-freezing so the unowned draft can be finalized.\n        canAutoFreeze_: true,\n        unfinalizedDrafts_: 0\n    };\n}\nfunction usePatchesInScope(scope, patchListener) {\n    if (patchListener) {\n        getPlugin(\"Patches\");\n        scope.patches_ = [];\n        scope.inversePatches_ = [];\n        scope.patchListener_ = patchListener;\n    }\n}\nfunction revokeScope(scope) {\n    leaveScope(scope);\n    scope.drafts_.forEach(revokeDraft);\n    scope.drafts_ = null;\n}\nfunction leaveScope(scope) {\n    if (scope === currentScope) {\n        currentScope = scope.parent_;\n    }\n}\nfunction enterScope(immer2) {\n    return currentScope = createScope(currentScope, immer2);\n}\nfunction revokeDraft(draft) {\n    const state = draft[DRAFT_STATE];\n    if (state.type_ === 0 /* Object */  || state.type_ === 1 /* Array */ ) state.revoke_();\n    else state.revoked_ = true;\n}\n// src/core/finalize.ts\nfunction processResult(result, scope) {\n    scope.unfinalizedDrafts_ = scope.drafts_.length;\n    const baseDraft = scope.drafts_[0];\n    const isReplaced = result !== void 0 && result !== baseDraft;\n    if (isReplaced) {\n        if (baseDraft[DRAFT_STATE].modified_) {\n            revokeScope(scope);\n            die(4);\n        }\n        if (isDraftable(result)) {\n            result = finalize(scope, result);\n            if (!scope.parent_) maybeFreeze(scope, result);\n        }\n        if (scope.patches_) {\n            getPlugin(\"Patches\").generateReplacementPatches_(baseDraft[DRAFT_STATE].base_, result, scope.patches_, scope.inversePatches_);\n        }\n    } else {\n        result = finalize(scope, baseDraft, []);\n    }\n    revokeScope(scope);\n    if (scope.patches_) {\n        scope.patchListener_(scope.patches_, scope.inversePatches_);\n    }\n    return result !== NOTHING ? result : void 0;\n}\nfunction finalize(rootScope, value, path) {\n    if (isFrozen(value)) return value;\n    const useStrictIteration = rootScope.immer_.shouldUseStrictIteration();\n    const state = value[DRAFT_STATE];\n    if (!state) {\n        each(value, (key, childValue)=>finalizeProperty(rootScope, state, value, key, childValue, path), useStrictIteration);\n        return value;\n    }\n    if (state.scope_ !== rootScope) return value;\n    if (!state.modified_) {\n        maybeFreeze(rootScope, state.base_, true);\n        return state.base_;\n    }\n    if (!state.finalized_) {\n        state.finalized_ = true;\n        state.scope_.unfinalizedDrafts_--;\n        const result = state.copy_;\n        let resultEach = result;\n        let isSet2 = false;\n        if (state.type_ === 3 /* Set */ ) {\n            resultEach = new Set(result);\n            result.clear();\n            isSet2 = true;\n        }\n        each(resultEach, (key, childValue)=>finalizeProperty(rootScope, state, result, key, childValue, path, isSet2), useStrictIteration);\n        maybeFreeze(rootScope, result, false);\n        if (path && rootScope.patches_) {\n            getPlugin(\"Patches\").generatePatches_(state, path, rootScope.patches_, rootScope.inversePatches_);\n        }\n    }\n    return state.copy_;\n}\nfunction finalizeProperty(rootScope, parentState, targetObject, prop, childValue, rootPath, targetIsSet) {\n    if (childValue == null) {\n        return;\n    }\n    if (typeof childValue !== \"object\" && !targetIsSet) {\n        return;\n    }\n    const childIsFrozen = isFrozen(childValue);\n    if (childIsFrozen && !targetIsSet) {\n        return;\n    }\n    if ( true && childValue === targetObject) die(5);\n    if (isDraft(childValue)) {\n        const path = rootPath && parentState && parentState.type_ !== 3 /* Set */  && // Set objects are atomic since they have no keys.\n        !has(parentState.assigned_, prop) ? rootPath.concat(prop) : void 0;\n        const res = finalize(rootScope, childValue, path);\n        set(targetObject, prop, res);\n        if (isDraft(res)) {\n            rootScope.canAutoFreeze_ = false;\n        } else return;\n    } else if (targetIsSet) {\n        targetObject.add(childValue);\n    }\n    if (isDraftable(childValue) && !childIsFrozen) {\n        if (!rootScope.immer_.autoFreeze_ && rootScope.unfinalizedDrafts_ < 1) {\n            return;\n        }\n        if (parentState && parentState.base_ && parentState.base_[prop] === childValue && childIsFrozen) {\n            return;\n        }\n        finalize(rootScope, childValue);\n        if ((!parentState || !parentState.scope_.parent_) && typeof prop !== \"symbol\" && (isMap(targetObject) ? targetObject.has(prop) : Object.prototype.propertyIsEnumerable.call(targetObject, prop))) maybeFreeze(rootScope, childValue);\n    }\n}\nfunction maybeFreeze(scope, value, deep = false) {\n    if (!scope.parent_ && scope.immer_.autoFreeze_ && scope.canAutoFreeze_) {\n        freeze(value, deep);\n    }\n}\n// src/core/proxy.ts\nfunction createProxyProxy(base, parent) {\n    const isArray = Array.isArray(base);\n    const state = {\n        type_: isArray ? 1 /* Array */  : 0 /* Object */ ,\n        // Track which produce call this is associated with.\n        scope_: parent ? parent.scope_ : getCurrentScope(),\n        // True for both shallow and deep changes.\n        modified_: false,\n        // Used during finalization.\n        finalized_: false,\n        // Track which properties have been assigned (true) or deleted (false).\n        assigned_: {},\n        // The parent draft state.\n        parent_: parent,\n        // The base state.\n        base_: base,\n        // The base proxy.\n        draft_: null,\n        // set below\n        // The base copy with any updated values.\n        copy_: null,\n        // Called by the `produce` function.\n        revoke_: null,\n        isManual_: false\n    };\n    let target = state;\n    let traps = objectTraps;\n    if (isArray) {\n        target = [\n            state\n        ];\n        traps = arrayTraps;\n    }\n    const { revoke, proxy } = Proxy.revocable(target, traps);\n    state.draft_ = proxy;\n    state.revoke_ = revoke;\n    return proxy;\n}\nvar objectTraps = {\n    get (state, prop) {\n        if (prop === DRAFT_STATE) return state;\n        const source = latest(state);\n        if (!has(source, prop)) {\n            return readPropFromProto(state, source, prop);\n        }\n        const value = source[prop];\n        if (state.finalized_ || !isDraftable(value)) {\n            return value;\n        }\n        if (value === peek(state.base_, prop)) {\n            prepareCopy(state);\n            return state.copy_[prop] = createProxy(value, state);\n        }\n        return value;\n    },\n    has (state, prop) {\n        return prop in latest(state);\n    },\n    ownKeys (state) {\n        return Reflect.ownKeys(latest(state));\n    },\n    set (state, prop, value) {\n        const desc = getDescriptorFromProto(latest(state), prop);\n        if (desc?.set) {\n            desc.set.call(state.draft_, value);\n            return true;\n        }\n        if (!state.modified_) {\n            const current2 = peek(latest(state), prop);\n            const currentState = current2?.[DRAFT_STATE];\n            if (currentState && currentState.base_ === value) {\n                state.copy_[prop] = value;\n                state.assigned_[prop] = false;\n                return true;\n            }\n            if (is(value, current2) && (value !== void 0 || has(state.base_, prop))) return true;\n            prepareCopy(state);\n            markChanged(state);\n        }\n        if (state.copy_[prop] === value && // special case: handle new props with value 'undefined'\n        (value !== void 0 || prop in state.copy_) || // special case: NaN\n        Number.isNaN(value) && Number.isNaN(state.copy_[prop])) return true;\n        state.copy_[prop] = value;\n        state.assigned_[prop] = true;\n        return true;\n    },\n    deleteProperty (state, prop) {\n        if (peek(state.base_, prop) !== void 0 || prop in state.base_) {\n            state.assigned_[prop] = false;\n            prepareCopy(state);\n            markChanged(state);\n        } else {\n            delete state.assigned_[prop];\n        }\n        if (state.copy_) {\n            delete state.copy_[prop];\n        }\n        return true;\n    },\n    // Note: We never coerce `desc.value` into an Immer draft, because we can't make\n    // the same guarantee in ES5 mode.\n    getOwnPropertyDescriptor (state, prop) {\n        const owner = latest(state);\n        const desc = Reflect.getOwnPropertyDescriptor(owner, prop);\n        if (!desc) return desc;\n        return {\n            writable: true,\n            configurable: state.type_ !== 1 /* Array */  || prop !== \"length\",\n            enumerable: desc.enumerable,\n            value: owner[prop]\n        };\n    },\n    defineProperty () {\n        die(11);\n    },\n    getPrototypeOf (state) {\n        return getPrototypeOf(state.base_);\n    },\n    setPrototypeOf () {\n        die(12);\n    }\n};\nvar arrayTraps = {};\neach(objectTraps, (key, fn)=>{\n    arrayTraps[key] = function() {\n        arguments[0] = arguments[0][0];\n        return fn.apply(this, arguments);\n    };\n});\narrayTraps.deleteProperty = function(state, prop) {\n    if ( true && isNaN(parseInt(prop))) die(13);\n    return arrayTraps.set.call(this, state, prop, void 0);\n};\narrayTraps.set = function(state, prop, value) {\n    if ( true && prop !== \"length\" && isNaN(parseInt(prop))) die(14);\n    return objectTraps.set.call(this, state[0], prop, value, state[0]);\n};\nfunction peek(draft, prop) {\n    const state = draft[DRAFT_STATE];\n    const source = state ? latest(state) : draft;\n    return source[prop];\n}\nfunction readPropFromProto(state, source, prop) {\n    const desc = getDescriptorFromProto(source, prop);\n    return desc ? `value` in desc ? desc.value : // This is a very special case, if the prop is a getter defined by the\n    // prototype, we should invoke it with the draft as context!\n    desc.get?.call(state.draft_) : void 0;\n}\nfunction getDescriptorFromProto(source, prop) {\n    if (!(prop in source)) return void 0;\n    let proto = getPrototypeOf(source);\n    while(proto){\n        const desc = Object.getOwnPropertyDescriptor(proto, prop);\n        if (desc) return desc;\n        proto = getPrototypeOf(proto);\n    }\n    return void 0;\n}\nfunction markChanged(state) {\n    if (!state.modified_) {\n        state.modified_ = true;\n        if (state.parent_) {\n            markChanged(state.parent_);\n        }\n    }\n}\nfunction prepareCopy(state) {\n    if (!state.copy_) {\n        state.copy_ = shallowCopy(state.base_, state.scope_.immer_.useStrictShallowCopy_);\n    }\n}\n// src/core/immerClass.ts\nvar Immer2 = class {\n    constructor(config){\n        this.autoFreeze_ = true;\n        this.useStrictShallowCopy_ = false;\n        this.useStrictIteration_ = true;\n        /**\n     * The `produce` function takes a value and a \"recipe function\" (whose\n     * return value often depends on the base state). The recipe function is\n     * free to mutate its first argument however it wants. All mutations are\n     * only ever applied to a __copy__ of the base state.\n     *\n     * Pass only a function to create a \"curried producer\" which relieves you\n     * from passing the recipe function every time.\n     *\n     * Only plain objects and arrays are made mutable. All other objects are\n     * considered uncopyable.\n     *\n     * Note: This function is __bound__ to its `Immer` instance.\n     *\n     * @param {any} base - the initial state\n     * @param {Function} recipe - function that receives a proxy of the base state as first argument and which can be freely modified\n     * @param {Function} patchListener - optional function that will be called with all the patches produced here\n     * @returns {any} a new state, or the initial state if nothing was modified\n     */ this.produce = (base, recipe, patchListener)=>{\n            if (typeof base === \"function\" && typeof recipe !== \"function\") {\n                const defaultBase = recipe;\n                recipe = base;\n                const self = this;\n                return function curriedProduce(base2 = defaultBase, ...args) {\n                    return self.produce(base2, (draft)=>recipe.call(this, draft, ...args));\n                };\n            }\n            if (typeof recipe !== \"function\") die(6);\n            if (patchListener !== void 0 && typeof patchListener !== \"function\") die(7);\n            let result;\n            if (isDraftable(base)) {\n                const scope = enterScope(this);\n                const proxy = createProxy(base, void 0);\n                let hasError = true;\n                try {\n                    result = recipe(proxy);\n                    hasError = false;\n                } finally{\n                    if (hasError) revokeScope(scope);\n                    else leaveScope(scope);\n                }\n                usePatchesInScope(scope, patchListener);\n                return processResult(result, scope);\n            } else if (!base || typeof base !== \"object\") {\n                result = recipe(base);\n                if (result === void 0) result = base;\n                if (result === NOTHING) result = void 0;\n                if (this.autoFreeze_) freeze(result, true);\n                if (patchListener) {\n                    const p = [];\n                    const ip = [];\n                    getPlugin(\"Patches\").generateReplacementPatches_(base, result, p, ip);\n                    patchListener(p, ip);\n                }\n                return result;\n            } else die(1, base);\n        };\n        this.produceWithPatches = (base, recipe)=>{\n            if (typeof base === \"function\") {\n                return (state, ...args)=>this.produceWithPatches(state, (draft)=>base(draft, ...args));\n            }\n            let patches, inversePatches;\n            const result = this.produce(base, recipe, (p, ip)=>{\n                patches = p;\n                inversePatches = ip;\n            });\n            return [\n                result,\n                patches,\n                inversePatches\n            ];\n        };\n        if (typeof config?.autoFreeze === \"boolean\") this.setAutoFreeze(config.autoFreeze);\n        if (typeof config?.useStrictShallowCopy === \"boolean\") this.setUseStrictShallowCopy(config.useStrictShallowCopy);\n        if (typeof config?.useStrictIteration === \"boolean\") this.setUseStrictIteration(config.useStrictIteration);\n    }\n    createDraft(base) {\n        if (!isDraftable(base)) die(8);\n        if (isDraft(base)) base = current(base);\n        const scope = enterScope(this);\n        const proxy = createProxy(base, void 0);\n        proxy[DRAFT_STATE].isManual_ = true;\n        leaveScope(scope);\n        return proxy;\n    }\n    finishDraft(draft, patchListener) {\n        const state = draft && draft[DRAFT_STATE];\n        if (!state || !state.isManual_) die(9);\n        const { scope_: scope } = state;\n        usePatchesInScope(scope, patchListener);\n        return processResult(void 0, scope);\n    }\n    /**\n   * Pass true to automatically freeze all copies created by Immer.\n   *\n   * By default, auto-freezing is enabled.\n   */ setAutoFreeze(value) {\n        this.autoFreeze_ = value;\n    }\n    /**\n   * Pass true to enable strict shallow copy.\n   *\n   * By default, immer does not copy the object descriptors such as getter, setter and non-enumrable properties.\n   */ setUseStrictShallowCopy(value) {\n        this.useStrictShallowCopy_ = value;\n    }\n    /**\n   * Pass false to use faster iteration that skips non-enumerable properties\n   * but still handles symbols for compatibility.\n   *\n   * By default, strict iteration is enabled (includes all own properties).\n   */ setUseStrictIteration(value) {\n        this.useStrictIteration_ = value;\n    }\n    shouldUseStrictIteration() {\n        return this.useStrictIteration_;\n    }\n    applyPatches(base, patches) {\n        let i;\n        for(i = patches.length - 1; i >= 0; i--){\n            const patch = patches[i];\n            if (patch.path.length === 0 && patch.op === \"replace\") {\n                base = patch.value;\n                break;\n            }\n        }\n        if (i > -1) {\n            patches = patches.slice(i + 1);\n        }\n        const applyPatchesImpl = getPlugin(\"Patches\").applyPatches_;\n        if (isDraft(base)) {\n            return applyPatchesImpl(base, patches);\n        }\n        return this.produce(base, (draft)=>applyPatchesImpl(draft, patches));\n    }\n};\nfunction createProxy(value, parent) {\n    const draft = isMap(value) ? getPlugin(\"MapSet\").proxyMap_(value, parent) : isSet(value) ? getPlugin(\"MapSet\").proxySet_(value, parent) : createProxyProxy(value, parent);\n    const scope = parent ? parent.scope_ : getCurrentScope();\n    scope.drafts_.push(draft);\n    return draft;\n}\n// src/core/current.ts\nfunction current(value) {\n    if (!isDraft(value)) die(10, value);\n    return currentImpl(value);\n}\nfunction currentImpl(value) {\n    if (!isDraftable(value) || isFrozen(value)) return value;\n    const state = value[DRAFT_STATE];\n    let copy;\n    let strict = true;\n    if (state) {\n        if (!state.modified_) return state.base_;\n        state.finalized_ = true;\n        copy = shallowCopy(value, state.scope_.immer_.useStrictShallowCopy_);\n        strict = state.scope_.immer_.shouldUseStrictIteration();\n    } else {\n        copy = shallowCopy(value, true);\n    }\n    each(copy, (key, childValue)=>{\n        set(copy, key, currentImpl(childValue));\n    }, strict);\n    if (state) {\n        state.finalized_ = false;\n    }\n    return copy;\n}\n// src/plugins/patches.ts\nfunction enablePatches() {\n    const errorOffset = 16;\n    if (true) {\n        errors.push('Sets cannot have \"replace\" patches.', function(op) {\n            return \"Unsupported patch operation: \" + op;\n        }, function(path) {\n            return \"Cannot apply patch, path doesn't resolve: \" + path;\n        }, \"Patching reserved attributes like __proto__, prototype and constructor is not allowed\");\n    }\n    const REPLACE = \"replace\";\n    const ADD = \"add\";\n    const REMOVE = \"remove\";\n    function generatePatches_(state, basePath, patches, inversePatches) {\n        switch(state.type_){\n            case 0 /* Object */ :\n            case 2 /* Map */ :\n                return generatePatchesFromAssigned(state, basePath, patches, inversePatches);\n            case 1 /* Array */ :\n                return generateArrayPatches(state, basePath, patches, inversePatches);\n            case 3 /* Set */ :\n                return generateSetPatches(state, basePath, patches, inversePatches);\n        }\n    }\n    function generateArrayPatches(state, basePath, patches, inversePatches) {\n        let { base_, assigned_ } = state;\n        let copy_ = state.copy_;\n        if (copy_.length < base_.length) {\n            ;\n            [base_, copy_] = [\n                copy_,\n                base_\n            ];\n            [patches, inversePatches] = [\n                inversePatches,\n                patches\n            ];\n        }\n        for(let i = 0; i < base_.length; i++){\n            if (assigned_[i] && copy_[i] !== base_[i]) {\n                const path = basePath.concat([\n                    i\n                ]);\n                patches.push({\n                    op: REPLACE,\n                    path,\n                    // Need to maybe clone it, as it can in fact be the original value\n                    // due to the base/copy inversion at the start of this function\n                    value: clonePatchValueIfNeeded(copy_[i])\n                });\n                inversePatches.push({\n                    op: REPLACE,\n                    path,\n                    value: clonePatchValueIfNeeded(base_[i])\n                });\n            }\n        }\n        for(let i = base_.length; i < copy_.length; i++){\n            const path = basePath.concat([\n                i\n            ]);\n            patches.push({\n                op: ADD,\n                path,\n                // Need to maybe clone it, as it can in fact be the original value\n                // due to the base/copy inversion at the start of this function\n                value: clonePatchValueIfNeeded(copy_[i])\n            });\n        }\n        for(let i = copy_.length - 1; base_.length <= i; --i){\n            const path = basePath.concat([\n                i\n            ]);\n            inversePatches.push({\n                op: REMOVE,\n                path\n            });\n        }\n    }\n    function generatePatchesFromAssigned(state, basePath, patches, inversePatches) {\n        const { base_, copy_ } = state;\n        each(state.assigned_, (key, assignedValue)=>{\n            const origValue = get(base_, key);\n            const value = get(copy_, key);\n            const op = !assignedValue ? REMOVE : has(base_, key) ? REPLACE : ADD;\n            if (origValue === value && op === REPLACE) return;\n            const path = basePath.concat(key);\n            patches.push(op === REMOVE ? {\n                op,\n                path\n            } : {\n                op,\n                path,\n                value\n            });\n            inversePatches.push(op === ADD ? {\n                op: REMOVE,\n                path\n            } : op === REMOVE ? {\n                op: ADD,\n                path,\n                value: clonePatchValueIfNeeded(origValue)\n            } : {\n                op: REPLACE,\n                path,\n                value: clonePatchValueIfNeeded(origValue)\n            });\n        });\n    }\n    function generateSetPatches(state, basePath, patches, inversePatches) {\n        let { base_, copy_ } = state;\n        let i = 0;\n        base_.forEach((value)=>{\n            if (!copy_.has(value)) {\n                const path = basePath.concat([\n                    i\n                ]);\n                patches.push({\n                    op: REMOVE,\n                    path,\n                    value\n                });\n                inversePatches.unshift({\n                    op: ADD,\n                    path,\n                    value\n                });\n            }\n            i++;\n        });\n        i = 0;\n        copy_.forEach((value)=>{\n            if (!base_.has(value)) {\n                const path = basePath.concat([\n                    i\n                ]);\n                patches.push({\n                    op: ADD,\n                    path,\n                    value\n                });\n                inversePatches.unshift({\n                    op: REMOVE,\n                    path,\n                    value\n                });\n            }\n            i++;\n        });\n    }\n    function generateReplacementPatches_(baseValue, replacement, patches, inversePatches) {\n        patches.push({\n            op: REPLACE,\n            path: [],\n            value: replacement === NOTHING ? void 0 : replacement\n        });\n        inversePatches.push({\n            op: REPLACE,\n            path: [],\n            value: baseValue\n        });\n    }\n    function applyPatches_(draft, patches) {\n        patches.forEach((patch)=>{\n            const { path, op } = patch;\n            let base = draft;\n            for(let i = 0; i < path.length - 1; i++){\n                const parentType = getArchtype(base);\n                let p = path[i];\n                if (typeof p !== \"string\" && typeof p !== \"number\") {\n                    p = \"\" + p;\n                }\n                if ((parentType === 0 /* Object */  || parentType === 1 /* Array */ ) && (p === \"__proto__\" || p === \"constructor\")) die(errorOffset + 3);\n                if (typeof base === \"function\" && p === \"prototype\") die(errorOffset + 3);\n                base = get(base, p);\n                if (typeof base !== \"object\") die(errorOffset + 2, path.join(\"/\"));\n            }\n            const type = getArchtype(base);\n            const value = deepClonePatchValue(patch.value);\n            const key = path[path.length - 1];\n            switch(op){\n                case REPLACE:\n                    switch(type){\n                        case 2 /* Map */ :\n                            return base.set(key, value);\n                        case 3 /* Set */ :\n                            die(errorOffset);\n                        default:\n                            return base[key] = value;\n                    }\n                case ADD:\n                    switch(type){\n                        case 1 /* Array */ :\n                            return key === \"-\" ? base.push(value) : base.splice(key, 0, value);\n                        case 2 /* Map */ :\n                            return base.set(key, value);\n                        case 3 /* Set */ :\n                            return base.add(value);\n                        default:\n                            return base[key] = value;\n                    }\n                case REMOVE:\n                    switch(type){\n                        case 1 /* Array */ :\n                            return base.splice(key, 1);\n                        case 2 /* Map */ :\n                            return base.delete(key);\n                        case 3 /* Set */ :\n                            return base.delete(patch.value);\n                        default:\n                            return delete base[key];\n                    }\n                default:\n                    die(errorOffset + 1, op);\n            }\n        });\n        return draft;\n    }\n    function deepClonePatchValue(obj) {\n        if (!isDraftable(obj)) return obj;\n        if (Array.isArray(obj)) return obj.map(deepClonePatchValue);\n        if (isMap(obj)) return new Map(Array.from(obj.entries()).map(([k, v])=>[\n                k,\n                deepClonePatchValue(v)\n            ]));\n        if (isSet(obj)) return new Set(Array.from(obj).map(deepClonePatchValue));\n        const cloned = Object.create(getPrototypeOf(obj));\n        for(const key in obj)cloned[key] = deepClonePatchValue(obj[key]);\n        if (has(obj, DRAFTABLE)) cloned[DRAFTABLE] = obj[DRAFTABLE];\n        return cloned;\n    }\n    function clonePatchValueIfNeeded(obj) {\n        if (isDraft(obj)) {\n            return deepClonePatchValue(obj);\n        } else return obj;\n    }\n    loadPlugin(\"Patches\", {\n        applyPatches_,\n        generatePatches_,\n        generateReplacementPatches_\n    });\n}\n// src/plugins/mapset.ts\nfunction enableMapSet() {\n    class DraftMap extends Map {\n        constructor(target, parent){\n            super();\n            this[DRAFT_STATE] = {\n                type_: 2 /* Map */ ,\n                parent_: parent,\n                scope_: parent ? parent.scope_ : getCurrentScope(),\n                modified_: false,\n                finalized_: false,\n                copy_: void 0,\n                assigned_: void 0,\n                base_: target,\n                draft_: this,\n                isManual_: false,\n                revoked_: false\n            };\n        }\n        get size() {\n            return latest(this[DRAFT_STATE]).size;\n        }\n        has(key) {\n            return latest(this[DRAFT_STATE]).has(key);\n        }\n        set(key, value) {\n            const state = this[DRAFT_STATE];\n            assertUnrevoked(state);\n            if (!latest(state).has(key) || latest(state).get(key) !== value) {\n                prepareMapCopy(state);\n                markChanged(state);\n                state.assigned_.set(key, true);\n                state.copy_.set(key, value);\n                state.assigned_.set(key, true);\n            }\n            return this;\n        }\n        delete(key) {\n            if (!this.has(key)) {\n                return false;\n            }\n            const state = this[DRAFT_STATE];\n            assertUnrevoked(state);\n            prepareMapCopy(state);\n            markChanged(state);\n            if (state.base_.has(key)) {\n                state.assigned_.set(key, false);\n            } else {\n                state.assigned_.delete(key);\n            }\n            state.copy_.delete(key);\n            return true;\n        }\n        clear() {\n            const state = this[DRAFT_STATE];\n            assertUnrevoked(state);\n            if (latest(state).size) {\n                prepareMapCopy(state);\n                markChanged(state);\n                state.assigned_ = /* @__PURE__ */ new Map();\n                each(state.base_, (key)=>{\n                    state.assigned_.set(key, false);\n                });\n                state.copy_.clear();\n            }\n        }\n        forEach(cb, thisArg) {\n            const state = this[DRAFT_STATE];\n            latest(state).forEach((_value, key, _map)=>{\n                cb.call(thisArg, this.get(key), key, this);\n            });\n        }\n        get(key) {\n            const state = this[DRAFT_STATE];\n            assertUnrevoked(state);\n            const value = latest(state).get(key);\n            if (state.finalized_ || !isDraftable(value)) {\n                return value;\n            }\n            if (value !== state.base_.get(key)) {\n                return value;\n            }\n            const draft = createProxy(value, state);\n            prepareMapCopy(state);\n            state.copy_.set(key, draft);\n            return draft;\n        }\n        keys() {\n            return latest(this[DRAFT_STATE]).keys();\n        }\n        values() {\n            const iterator = this.keys();\n            return {\n                [Symbol.iterator]: ()=>this.values(),\n                next: ()=>{\n                    const r = iterator.next();\n                    if (r.done) return r;\n                    const value = this.get(r.value);\n                    return {\n                        done: false,\n                        value\n                    };\n                }\n            };\n        }\n        entries() {\n            const iterator = this.keys();\n            return {\n                [Symbol.iterator]: ()=>this.entries(),\n                next: ()=>{\n                    const r = iterator.next();\n                    if (r.done) return r;\n                    const value = this.get(r.value);\n                    return {\n                        done: false,\n                        value: [\n                            r.value,\n                            value\n                        ]\n                    };\n                }\n            };\n        }\n        [(DRAFT_STATE, Symbol.iterator)]() {\n            return this.entries();\n        }\n    }\n    function proxyMap_(target, parent) {\n        return new DraftMap(target, parent);\n    }\n    function prepareMapCopy(state) {\n        if (!state.copy_) {\n            state.assigned_ = /* @__PURE__ */ new Map();\n            state.copy_ = new Map(state.base_);\n        }\n    }\n    class DraftSet extends Set {\n        constructor(target, parent){\n            super();\n            this[DRAFT_STATE] = {\n                type_: 3 /* Set */ ,\n                parent_: parent,\n                scope_: parent ? parent.scope_ : getCurrentScope(),\n                modified_: false,\n                finalized_: false,\n                copy_: void 0,\n                base_: target,\n                draft_: this,\n                drafts_: /* @__PURE__ */ new Map(),\n                revoked_: false,\n                isManual_: false\n            };\n        }\n        get size() {\n            return latest(this[DRAFT_STATE]).size;\n        }\n        has(value) {\n            const state = this[DRAFT_STATE];\n            assertUnrevoked(state);\n            if (!state.copy_) {\n                return state.base_.has(value);\n            }\n            if (state.copy_.has(value)) return true;\n            if (state.drafts_.has(value) && state.copy_.has(state.drafts_.get(value))) return true;\n            return false;\n        }\n        add(value) {\n            const state = this[DRAFT_STATE];\n            assertUnrevoked(state);\n            if (!this.has(value)) {\n                prepareSetCopy(state);\n                markChanged(state);\n                state.copy_.add(value);\n            }\n            return this;\n        }\n        delete(value) {\n            if (!this.has(value)) {\n                return false;\n            }\n            const state = this[DRAFT_STATE];\n            assertUnrevoked(state);\n            prepareSetCopy(state);\n            markChanged(state);\n            return state.copy_.delete(value) || (state.drafts_.has(value) ? state.copy_.delete(state.drafts_.get(value)) : /* istanbul ignore next */ false);\n        }\n        clear() {\n            const state = this[DRAFT_STATE];\n            assertUnrevoked(state);\n            if (latest(state).size) {\n                prepareSetCopy(state);\n                markChanged(state);\n                state.copy_.clear();\n            }\n        }\n        values() {\n            const state = this[DRAFT_STATE];\n            assertUnrevoked(state);\n            prepareSetCopy(state);\n            return state.copy_.values();\n        }\n        entries() {\n            const state = this[DRAFT_STATE];\n            assertUnrevoked(state);\n            prepareSetCopy(state);\n            return state.copy_.entries();\n        }\n        keys() {\n            return this.values();\n        }\n        [(DRAFT_STATE, Symbol.iterator)]() {\n            return this.values();\n        }\n        forEach(cb, thisArg) {\n            const iterator = this.values();\n            let result = iterator.next();\n            while(!result.done){\n                cb.call(thisArg, result.value, result.value, this);\n                result = iterator.next();\n            }\n        }\n    }\n    function proxySet_(target, parent) {\n        return new DraftSet(target, parent);\n    }\n    function prepareSetCopy(state) {\n        if (!state.copy_) {\n            state.copy_ = /* @__PURE__ */ new Set();\n            state.base_.forEach((value)=>{\n                if (isDraftable(value)) {\n                    const draft = createProxy(value, state);\n                    state.drafts_.set(value, draft);\n                    state.copy_.add(draft);\n                } else {\n                    state.copy_.add(value);\n                }\n            });\n        }\n    }\n    function assertUnrevoked(state) {\n        if (state.revoked_) die(3, JSON.stringify(latest(state)));\n    }\n    loadPlugin(\"MapSet\", {\n        proxyMap_,\n        proxySet_\n    });\n}\n// src/immer.ts\nvar immer = new Immer2();\nvar produce = immer.produce;\nvar produceWithPatches = /* @__PURE__ */ immer.produceWithPatches.bind(immer);\nvar setAutoFreeze = /* @__PURE__ */ immer.setAutoFreeze.bind(immer);\nvar setUseStrictShallowCopy = /* @__PURE__ */ immer.setUseStrictShallowCopy.bind(immer);\nvar setUseStrictIteration = /* @__PURE__ */ immer.setUseStrictIteration.bind(immer);\nvar applyPatches = /* @__PURE__ */ immer.applyPatches.bind(immer);\nvar createDraft = /* @__PURE__ */ immer.createDraft.bind(immer);\nvar finishDraft = /* @__PURE__ */ immer.finishDraft.bind(immer);\nfunction castDraft(value) {\n    return value;\n}\nfunction castImmutable(value) {\n    return value;\n}\n //# sourceMappingURL=immer.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvaW1tZXIvZGlzdC9pbW1lci5tanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQSxtQkFBbUI7QUFDbkIsSUFBSUEsVUFBVUMsT0FBT0MsR0FBRyxDQUFDO0FBQ3pCLElBQUlDLFlBQVlGLE9BQU9DLEdBQUcsQ0FBQztBQUMzQixJQUFJRSxjQUFjSCxPQUFPQyxHQUFHLENBQUM7QUFFN0Isc0JBQXNCO0FBQ3RCLElBQUlHLFNBQVNDLEtBQXFDLEdBQUc7SUFDbkQsa0NBQWtDO0lBQ2xDLFNBQVNDLE1BQU07UUFDYixPQUFPLENBQUMsZ0JBQWdCLEVBQUVBLE9BQU8sZ0ZBQWdGLEVBQUVBLE9BQU8sd0NBQXdDLENBQUM7SUFDcks7SUFDQSxTQUFTQyxLQUFLO1FBQ1osT0FBTyxDQUFDLG1KQUFtSixFQUFFQSxNQUFNLENBQUMsQ0FBQztJQUN2SztJQUNBO0lBQ0EsU0FBU0MsSUFBSTtRQUNYLE9BQU8seUhBQXlIQTtJQUNsSTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBLFNBQVNELEtBQUs7UUFDWixPQUFPLENBQUMsZ0NBQWdDLEVBQUVBLE1BQU0sQ0FBQztJQUNuRDtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0EsU0FBU0EsS0FBSztRQUNaLE9BQU8sQ0FBQyxpQ0FBaUMsRUFBRUEsTUFBTSxDQUFDO0lBQ3BEO0NBR0QsR0FBRyxDQUFFO0FBQ04sU0FBU0UsSUFBSUMsS0FBSyxFQUFFLEdBQUdDLElBQUk7SUFDekIsSUFBSU4sSUFBcUMsRUFBRTtRQUN6QyxNQUFNTyxJQUFJUixNQUFNLENBQUNNLE1BQU07UUFDdkIsTUFBTUcsTUFBTSxPQUFPRCxNQUFNLGFBQWFBLEVBQUVFLEtBQUssQ0FBQyxNQUFNSCxRQUFRQztRQUM1RCxNQUFNLElBQUlHLE1BQU0sQ0FBQyxRQUFRLEVBQUVGLElBQUksQ0FBQztJQUNsQztJQUNBLE1BQU0sSUFBSUUsTUFDUixDQUFDLDJCQUEyQixFQUFFTCxN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Q3pDO2dCQUNsQjtZQUNGO1FBQ0Y7SUFDRjtJQUNBLFNBQVM4TixnQkFBZ0IzTCxLQUFLO1FBQzVCLElBQUlBLE1BQU1nRSxRQUFRLEVBQ2hCN0csSUFBSSxHQUFHb1AsS0FBS0MsU0FBUyxDQUFDM0wsT0FBT2I7SUFDakM7SUFDQXlDLFdBQVcsVUFBVTtRQUFFZ0g7UUFBV0M7SUFBVTtBQUM5QztBQUVBLGVBQWU7QUFDZixJQUFJK0MsUUFBUSxJQUFJNUU7QUFDaEIsSUFBSUcsVUFBVXlFLE1BQU16RSxPQUFPO0FBQzNCLElBQUlTLHFCQUFxQixhQUFhLEdBQUdnRSxNQUFNaEUsa0JBQWtCLENBQUNpRSxJQUFJLENBQ3BFRDtBQUVGLElBQUk1RCxnQkFBZ0IsYUFBYSxHQUFHNEQsTUFBTTVELGFBQWEsQ0FBQzZELElBQUksQ0FBQ0Q7QUFDN0QsSUFBSTFELDBCQUEwQixhQUFhLEdBQUcwRCxNQUFNMUQsdUJBQXVCLENBQUMyRCxJQUFJLENBQzlFRDtBQUVGLElBQUl6RCx3QkFBd0IsYUFBYSxHQUFHeUQsTUFBTXpELHFCQUFxQixDQUFDMEQsSUFBSSxDQUMxRUQ7QUFFRixJQUFJckQsZUFBZSxhQUFhLEdBQUdxRCxNQUFNckQsWUFBWSxDQUFDc0QsSUFBSSxDQUFDRDtBQUMzRCxJQUFJeEQsY0FBYyxhQUFhLEdBQUd3RCxNQUFNeEQsV0FBVyxDQUFDeUQsSUFBSSxDQUFDRDtBQUN6RCxJQUFJdEQsY0FBYyxhQUFhLEdBQUdzRCxNQUFNdEQsV0FBVyxDQUFDdUQsSUFBSSxDQUFDRDtBQUN6RCxTQUFTRSxVQUFVOU8sS0FBSztJQUN0QixPQUFPQTtBQUNUO0FBQ0EsU0FBUytPLGNBQWMvTyxLQUFLO0lBQzFCLE9BQU9BO0FBQ1Q7QUFzQkUsQ0FDRixrQ0FBa0MiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly90ZW1wby1hcHAvLi9ub2RlX21vZHVsZXMvaW1tZXIvZGlzdC9pbW1lci5tanM/YTRmNyJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBzcmMvdXRpbHMvZW52LnRzXG52YXIgTk9USElORyA9IFN5bWJvbC5mb3IoXCJpbW1lci1ub3RoaW5nXCIpO1xudmFyIERSQUZUQUJMRSA9IFN5bWJvbC5mb3IoXCJpbW1lci1kcmFmdGFibGVcIik7XG52YXIgRFJBRlRfU1RBVEUgPSBTeW1ib2wuZm9yKFwiaW1tZXItc3RhdGVcIik7XG5cbi8vIHNyYy91dGlscy9lcnJvcnMudHNcbnZhciBlcnJvcnMgPSBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyBbXG4gIC8vIEFsbCBlcnJvciBjb2Rlcywgc3RhcnRpbmcgYnkgMDpcbiAgZnVuY3Rpb24ocGx1Z2luKSB7XG4gICAgcmV0dXJuIGBUaGUgcGx1Z2luIGZvciAnJHtwbHVnaW59JyBoYXMgbm90IGJlZW4gbG9hZGVkIGludG8gSW1tZXIuIFRvIGVuYWJsZSB0aGUgcGx1Z2luLCBpbXBvcnQgYW5kIGNhbGwgXFxgZW5hYmxlJHtwbHVnaW59KClcXGAgd2hlbiBpbml0aWFsaXppbmcgeW91ciBhcHBsaWNhdGlvbi5gO1xuICB9LFxuICBmdW5jdGlvbih0aGluZykge1xuICAgIHJldHVybiBgcHJvZHVjZSBjYW4gb25seSBiZSBjYWxsZWQgb24gdGhpbmdzIHRoYXQgYXJlIGRyYWZ0YWJsZTogcGxhaW4gb2JqZWN0cywgYXJyYXlzLCBNYXAsIFNldCBvciBjbGFzc2VzIHRoYXQgYXJlIG1hcmtlZCB3aXRoICdbaW1tZXJhYmxlXTogdHJ1ZScuIEdvdCAnJHt0aGluZ30nYDtcbiAgfSxcbiAgXCJUaGlzIG9iamVjdCBoYXMgYmVlbiBmcm96ZW4gYW5kIHNob3VsZCBub3QgYmUgbXV0YXRlZFwiLFxuICBmdW5jdGlvbihkYXRhKSB7XG4gICAgcmV0dXJuIFwiQ2Fubm90IHVzZSBhIHByb3h5IHRoYXQgaGFzIGJlZW4gcmV2b2tlZC4gRGlkIHlvdSBwYXNzIGFuIG9iamVjdCBmcm9tIGluc2lkZSBhbiBpbW1lciBmdW5jdGlvbiB0byBhbiBhc3luYyBwcm9jZXNzPyBcIiArIGRhdGE7XG4gIH0sXG4gIFwiQW4gaW1tZXIgcHJvZHVjZXIgcmV0dXJuZWQgYSBuZXcgdmFsdWUgKmFuZCogbW9kaWZpZWQgaXRzIGRyYWZ0LiBFaXRoZXIgcmV0dXJuIGEgbmV3IHZhbHVlICpvciogbW9kaWZ5IHRoZSBkcmFmdC5cIixcbiAgXCJJbW1lciBmb3JiaWRzIGNpcmN1bGFyIHJlZmVyZW5jZXNcIixcbiAgXCJUaGUgZmlyc3Qgb3Igc2Vjb25kIGFyZ3VtZW50IHRvIGBwcm9kdWNlYCBtdXN0IGJlIGEgZnVuY3Rpb25cIixcbiAgXCJUaGUgdGhpcmQgYXJndW1lbnQgdG8gYHByb2R1Y2VgIG11c3QgYmUgYSBmdW5jdGlvbiBvciB1bmRlZmluZWRcIixcbiAgXCJGaXJzdCBhcmd1bWVudCB0byBgY3JlYXRlRHJhZnRgIG11c3QgYmUgYSBwbGFpbiBvYmplY3QsIGFuIGFycmF5LCBvciBhbiBpbW1lcmFibGUgb2JqZWN0XCIsXG4gIFwiRmlyc3QgYXJndW1lbnQgdG8gYGZpbmlzaERyYWZ0YCBtdXN0IGJlIGEgZHJhZnQgcmV0dXJuZWQgYnkgYGNyZWF0ZURyYWZ0YFwiLFxuICBmdW5jdGlvbih0aGluZykge1xuICAgIHJldHVybiBgJ2N1cnJlbnQnIGV4cGVjdHMgYSBkcmFmdCwgZ290OiAke3RoaW5nfWA7XG4gIH0sXG4gIFwiT2JqZWN0LmRlZmluZVByb3BlcnR5KCkgY2Fubm90IGJlIHVzZWQgb24gYW4gSW1tZXIgZHJhZnRcIixcbiAgXCJPYmplY3Quc2V0UHJvdG90eXBlT2YoKSBjYW5ub3QgYmUgdXNlZCBvbiBhbiBJbW1lciBkcmFmdFwiLFxuICBcIkltbWVyIG9ubHkgc3VwcG9ydHMgZGVsZXRpbmcgYXJyYXkgaW5kaWNlc1wiLFxuICBcIkltbWVyIG9ubHkgc3VwcG9ydHMgc2V0dGluZyBhcnJheSBpbmRpY2VzIGFuZCB0aGUgJ2xlbmd0aCcgcHJvcGVydHlcIixcbiAgZnVuY3Rpb24odGhpbmcpIHtcbiAgICByZXR1cm4gYCdvcmlnaW5hbCcgZXhwZWN0cyBhIGRyYWZ0LCBnb3Q6ICR7dGhpbmd9YDtcbiAgfVxuICAvLyBOb3RlOiBpZiBtb3JlIGVycm9ycyBhcmUgYWRkZWQsIHRoZSBlcnJvck9mZnNldCBpbiBQYXRjaGVzLnRzIHNob3VsZCBiZSBpbmNyZWFzZWRcbiAgLy8gU2VlIFBhdGNoZXMudHMgZm9yIGFkZGl0aW9uYWwgZXJyb3JzXG5dIDogW107XG5mdW5jdGlvbiBkaWUoZXJyb3IsIC4uLmFyZ3MpIHtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAgIGNvbnN0IGUgPSBlcnJvcnNbZXJyb3JdO1xuICAgIGNvbnN0IG1zZyA9IHR5cGVvZiBlID09PSBcImZ1bmN0aW9uXCIgPyBlLmFwcGx5KG51bGwsIGFyZ3MpIDogZTtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYFtJbW1lcl0gJHttc2d9YCk7XG4gIH1cbiAgdGhyb3cgbmV3IEVycm9yKFxuICAgIGBbSW1tZXJdIG1pbmlmaWVkIGVycm9yIG5yOiAke2Vycm9yfS4gRnVsbCBlcnJvciBhdDogaHR0cHM6Ly9iaXQubHkvM2NYRUtXZmBcbiAgKTtcbn1cblxuLy8gc3JjL3V0aWxzL2NvbW1vbi50c1xudmFyIGdldFByb3RvdHlwZU9mID0gT2JqZWN0LmdldFByb3RvdHlwZU9mO1xuZnVuY3Rpb24gaXNEcmFmdCh2YWx1ZSkge1xuICByZXR1cm4gISF2YWx1ZSAmJiAhIXZhbHVlW0RSQUZUX1NUQVRFXTtcbn1cbmZ1bmN0aW9uIGlzRHJhZnRhYmxlKHZhbHVlKSB7XG4gIGlmICghdmFsdWUpXG4gICAgcmV0dXJuIGZhbHNlO1xuICByZXR1cm4gaXNQbGFpbk9iamVjdCh2YWx1ZSkgfHwgQXJyYXkuaXNBcnJheSh2YWx1ZSkgfHwgISF2YWx1ZVtEUkFGVEFCTEVdIHx8ICEhdmFsdWUuY29uc3RydWN0b3I/LltEUkFGVEFCTEVdIHx8IGlzTWFwKHZhbHVlKSB8fCBpc1NldCh2YWx1ZSk7XG59XG52YXIgb2JqZWN0Q3RvclN0cmluZyA9IE9iamVjdC5wcm90b3R5cGUuY29uc3RydWN0b3IudG9TdHJpbmcoKTtcbnZhciBjYWNoZWRDdG9yU3RyaW5ncyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgV2Vha01hcCgpO1xuZnVuY3Rpb24gaXNQbGFpbk9iamVjdCh2YWx1ZSkge1xuICBpZiAoIXZhbHVlIHx8IHR5cGVvZiB2YWx1ZSAhPT0gXCJvYmplY3RcIilcbiAgICByZXR1cm4gZmFsc2U7XG4gIGNvbnN0IHByb3RvID0gT2JqZWN0LmdldFByb3RvdHlwZU9mKHZhbHVlKTtcbiAgaWYgKHByb3RvID09PSBudWxsIHx8IHByb3RvID09PSBPYmplY3QucHJvdG90eXBlKVxuICAgIHJldHVybiB0cnVlO1xuICBjb25zdCBDdG9yID0gT2JqZWN0Lmhhc093blByb3BlcnR5LmNhbGwocHJvdG8sIFwiY29uc3RydWN0b3JcIikgJiYgcHJvdG8uY29uc3RydWN0b3I7XG4gIGlmIChDdG9yID09PSBPYmplY3QpXG4gICAgcmV0dXJuIHRydWU7XG4gIGlmICh0eXBlb2YgQ3RvciAhPT0gXCJmdW5jdGlvblwiKVxuICAgIHJldHVybiBmYWxzZTtcbiAgbGV0IGN0b3JTdHJpbmcgPSBjYWNoZWRDdG9yU3RyaW5ncy5nZXQoQ3Rvcik7XG4gIGlmIChjdG9yU3RyaW5nID09PSB2b2lkIDApIHtcbiAgICBjdG9yU3RyaW5nID0gRnVuY3Rpb24udG9TdHJpbmcuY2FsbChDdG9yKTtcbiAgICBjYWNoZWRDdG9yU3RyaW5ncy5zZXQoQ3RvciwgY3RvclN0cmluZyk7XG4gIH1cbiAgcmV0dXJuIGN0b3JTdHJpbmcgPT09IG9iamVjdEN0b3JTdHJpbmc7XG59XG5mdW5jdGlvbiBvcmlnaW5hbCh2YWx1ZSkge1xuICBpZiAoIWlzRHJhZnQodmFsdWUpKVxuICAgIGRpZSgxNSwgdmFsdWUpO1xuICByZXR1cm4gdmFsdWVbRFJBRlRfU1RBVEVdLmJhc2VfO1xufVxuZnVuY3Rpb24gZWFjaChvYmosIGl0ZXIsIHN0cmljdCA9IHRydWUpIHtcbiAgaWYgKGdldEFyY2h0eXBlKG9iaikgPT09IDAgLyogT2JqZWN0ICovKSB7XG4gICAgY29uc3Qga2V5cyA9IHN0cmljdCA/IFJlZmxlY3Qub3duS2V5cyhvYmopIDogT2JqZWN0LmtleXMob2JqKTtcbiAgICBrZXlzLmZvckVhY2goKGtleSkgPT4ge1xuICAgICAgaXRlcihrZXksIG9ialtrZXldLCBvYmopO1xuICAgIH0pO1xuICB9IGVsc2Uge1xuICAgIG9iai5mb3JFYWNoKChlbnRyeSwgaW5kZXgpID0+IGl0ZXIoaW5kZXgsIGVudHJ5LCBvYmopKTtcbiAgfVxufVxuZnVuY3Rpb24gZ2V0QXJjaHR5cGUodGhpbmcpIHtcbiAgY29uc3Qgc3RhdGUgPSB0aGluZ1tEUkFGVF9TVEFURV07XG4gIHJldHVybiBzdGF0ZSA/IHN0YXRlLnR5cGVfIDogQXJyYXkuaXNBcnJheSh0aGluZykgPyAxIC8qIEFycmF5ICovIDogaXNNYXAodGhpbmcpID8gMiAvKiBNYXAgKi8gOiBpc1NldCh0aGluZykgPyAzIC8qIFNldCAqLyA6IDAgLyogT2JqZWN0ICovO1xufVxuZnVuY3Rpb24gaGFzKHRoaW5nLCBwcm9wKSB7XG4gIHJldHVybiBnZXRBcmNodHlwZSh0aGluZykgPT09IDIgLyogTWFwICovID8gdGhpbmcuaGFzKHByb3ApIDogT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHRoaW5nLCBwcm9wKTtcbn1cbmZ1bmN0aW9uIGdldCh0aGluZywgcHJvcCkge1xuICByZXR1cm4gZ2V0QXJjaHR5cGUodGhpbmcpID09PSAyIC8qIE1hcCAqLyA/IHRoaW5nLmdldChwcm9wKSA6IHRoaW5nW3Byb3BdO1xufVxuZnVuY3Rpb24gc2V0KHRoaW5nLCBwcm9wT3JPbGRWYWx1ZSwgdmFsdWUpIHtcbiAgY29uc3QgdCA9IGdldEFyY2h0eXBlKHRoaW5nKTtcbiAgaWYgKHQgPT09IDIgLyogTWFwICovKVxuICAgIHRoaW5nLnNldChwcm9wT3JPbGRWYWx1ZSwgdmFsdWUpO1xuICBlbHNlIGlmICh0ID09PSAzIC8qIFNldCAqLykge1xuICAgIHRoaW5nLmFkZCh2YWx1ZSk7XG4gIH0gZWxzZVxuICAgIHRoaW5nW3Byb3BPck9sZFZhbHVlXSA9IHZhbHVlO1xufVxuZnVuY3Rpb24gaXMoeCwgeSkge1xuICBpZiAoeCA9PT0geSkge1xuICAgIHJldHVybiB4ICE9PSAwIHx8IDEgLyB4ID09PSAxIC8geTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4geCAhPT0geCAmJiB5ICE9PSB5O1xuICB9XG59XG5mdW5jdGlvbiBpc01hcCh0YXJnZXQpIHtcbiAgcmV0dXJuIHRhcmdldCBpbnN0YW5jZW9mIE1hcDtcbn1cbmZ1bmN0aW9uIGlzU2V0KHRhcmdldCkge1xuICByZXR1cm4gdGFyZ2V0IGluc3RhbmNlb2YgU2V0O1xufVxuZnVuY3Rpb24gbGF0ZXN0KHN0YXRlKSB7XG4gIHJldHVybiBzdGF0ZS5jb3B5XyB8fCBzdGF0ZS5iYXNlXztcbn1cbmZ1bmN0aW9uIHNoYWxsb3dDb3B5KGJhc2UsIHN0cmljdCkge1xuICBpZiAoaXNNYXAoYmFzZSkpIHtcbiAgICByZXR1cm4gbmV3IE1hcChiYXNlKTtcbiAgfVxuICBpZiAoaXNTZXQoYmFzZSkpIHtcbiAgICByZXR1cm4gbmV3IFNldChiYXNlKTtcbiAgfVxuICBpZiAoQXJyYXkuaXNBcnJheShiYXNlKSlcbiAgICByZXR1cm4gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYmFzZSk7XG4gIGNvbnN0IGlzUGxhaW4gPSBpc1BsYWluT2JqZWN0KGJhc2UpO1xuICBpZiAoc3RyaWN0ID09PSB0cnVlIHx8IHN0cmljdCA9PT0gXCJjbGFzc19vbmx5XCIgJiYgIWlzUGxhaW4pIHtcbiAgICBjb25zdCBkZXNjcmlwdG9ycyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKGJhc2UpO1xuICAgIGRlbGV0ZSBkZXNjcmlwdG9yc1tEUkFGVF9TVEFURV07XG4gICAgbGV0IGtleXMgPSBSZWZsZWN0Lm93bktleXMoZGVzY3JpcHRvcnMpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7IGkrKykge1xuICAgICAgY29uc3Qga2V5ID0ga2V5c1tpXTtcbiAgICAgIGNvbnN0IGRlc2MgPSBkZXNjcmlwdG9yc1trZXldO1xuICAgICAgaWYgKGRlc2Mud3JpdGFibGUgPT09IGZhbHNlKSB7XG4gICAgICAgIGRlc2Mud3JpdGFibGUgPSB0cnVlO1xuICAgICAgICBkZXNjLmNvbmZpZ3VyYWJsZSA9IHRydWU7XG4gICAgICB9XG4gICAgICBpZiAoZGVzYy5nZXQgfHwgZGVzYy5zZXQpXG4gICAgICAgIGRlc2NyaXB0b3JzW2tleV0gPSB7XG4gICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgIC8vIGNvdWxkIGxpdmUgd2l0aCAhIWRlc2Muc2V0IGFzIHdlbGwgaGVyZS4uLlxuICAgICAgICAgIGVudW1lcmFibGU6IGRlc2MuZW51bWVyYWJsZSxcbiAgICAgICAgICB2YWx1ZTogYmFzZVtrZXldXG4gICAgICAgIH07XG4gICAgfVxuICAgIHJldHVybiBPYmplY3QuY3JlYXRlKGdldFByb3RvdHlwZU9mKGJhc2UpLCBkZXNjcmlwdG9ycyk7XG4gIH0gZWxzZSB7XG4gICAgY29uc3QgcHJvdG8gPSBnZXRQcm90b3R5cGVPZihiYXNlKTtcbiAgICBpZiAocHJvdG8gIT09IG51bGwgJiYgaXNQbGFpbikge1xuICAgICAgcmV0dXJuIHsgLi4uYmFzZSB9O1xuICAgIH1cbiAgICBjb25zdCBvYmogPSBPYmplY3QuY3JlYXRlKHByb3RvKTtcbiAgICByZXR1cm4gT2JqZWN0LmFzc2lnbihvYmosIGJhc2UpO1xuICB9XG59XG5mdW5jdGlvbiBmcmVlemUob2JqLCBkZWVwID0gZmFsc2UpIHtcbiAgaWYgKGlzRnJvemVuKG9iaikgfHwgaXNEcmFmdChvYmopIHx8ICFpc0RyYWZ0YWJsZShvYmopKVxuICAgIHJldHVybiBvYmo7XG4gIGlmIChnZXRBcmNodHlwZShvYmopID4gMSkge1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKG9iaiwge1xuICAgICAgc2V0OiBkb250TXV0YXRlTWV0aG9kT3ZlcnJpZGUsXG4gICAgICBhZGQ6IGRvbnRNdXRhdGVNZXRob2RPdmVycmlkZSxcbiAgICAgIGNsZWFyOiBkb250TXV0YXRlTWV0aG9kT3ZlcnJpZGUsXG4gICAgICBkZWxldGU6IGRvbnRNdXRhdGVNZXRob2RPdmVycmlkZVxuICAgIH0pO1xuICB9XG4gIE9iamVjdC5mcmVlemUob2JqKTtcbiAgaWYgKGRlZXApXG4gICAgT2JqZWN0LnZhbHVlcyhvYmopLmZvckVhY2goKHZhbHVlKSA9PiBmcmVlemUodmFsdWUsIHRydWUpKTtcbiAgcmV0dXJuIG9iajtcbn1cbmZ1bmN0aW9uIGRvbnRNdXRhdGVGcm96ZW5Db2xsZWN0aW9ucygpIHtcbiAgZGllKDIpO1xufVxudmFyIGRvbnRNdXRhdGVNZXRob2RPdmVycmlkZSA9IHtcbiAgdmFsdWU6IGRvbnRNdXRhdGVGcm96ZW5Db2xsZWN0aW9uc1xufTtcbmZ1bmN0aW9uIGlzRnJvemVuKG9iaikge1xuICBpZiAob2JqID09PSBudWxsIHx8IHR5cGVvZiBvYmogIT09IFwib2JqZWN0XCIpXG4gICAgcmV0dXJuIHRydWU7XG4gIHJldHVybiBPYmplY3QuaXNGcm96ZW4ob2JqKTtcbn1cblxuLy8gc3JjL3V0aWxzL3BsdWdpbnMudHNcbnZhciBwbHVnaW5zID0ge307XG5mdW5jdGlvbiBnZXRQbHVnaW4ocGx1Z2luS2V5KSB7XG4gIGNvbnN0IHBsdWdpbiA9IHBsdWdpbnNbcGx1Z2luS2V5XTtcbiAgaWYgKCFwbHVnaW4pIHtcbiAgICBkaWUoMCwgcGx1Z2luS2V5KTtcbiAgfVxuICByZXR1cm4gcGx1Z2luO1xufVxuZnVuY3Rpb24gbG9hZFBsdWdpbihwbHVnaW5LZXksIGltcGxlbWVudGF0aW9uKSB7XG4gIGlmICghcGx1Z2luc1twbHVnaW5LZXldKVxuICAgIHBsdWdpbnNbcGx1Z2luS2V5XSA9IGltcGxlbWVudGF0aW9uO1xufVxuXG4vLyBzcmMvY29yZS9zY29wZS50c1xudmFyIGN1cnJlbnRTY29wZTtcbmZ1bmN0aW9uIGdldEN1cnJlbnRTY29wZSgpIHtcbiAgcmV0dXJuIGN1cnJlbnRTY29wZTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZVNjb3BlKHBhcmVudF8sIGltbWVyXykge1xuICByZXR1cm4ge1xuICAgIGRyYWZ0c186IFtdLFxuICAgIHBhcmVudF8sXG4gICAgaW1tZXJfLFxuICAgIC8vIFdoZW5ldmVyIHRoZSBtb2RpZmllZCBkcmFmdCBjb250YWlucyBhIGRyYWZ0IGZyb20gYW5vdGhlciBzY29wZSwgd2VcbiAgICAvLyBuZWVkIHRvIHByZXZlbnQgYXV0by1mcmVlemluZyBzbyB0aGUgdW5vd25lZCBkcmFmdCBjYW4gYmUgZmluYWxpemVkLlxuICAgIGNhbkF1dG9GcmVlemVfOiB0cnVlLFxuICAgIHVuZmluYWxpemVkRHJhZnRzXzogMFxuICB9O1xufVxuZnVuY3Rpb24gdXNlUGF0Y2hlc0luU2NvcGUoc2NvcGUsIHBhdGNoTGlzdGVuZXIpIHtcbiAgaWYgKHBhdGNoTGlzdGVuZXIpIHtcbiAgICBnZXRQbHVnaW4oXCJQYXRjaGVzXCIpO1xuICAgIHNjb3BlLnBhdGNoZXNfID0gW107XG4gICAgc2NvcGUuaW52ZXJzZVBhdGNoZXNfID0gW107XG4gICAgc2NvcGUucGF0Y2hMaXN0ZW5lcl8gPSBwYXRjaExpc3RlbmVyO1xuICB9XG59XG5mdW5jdGlvbiByZXZva2VTY29wZShzY29wZSkge1xuICBsZWF2ZVNjb3BlKHNjb3BlKTtcbiAgc2NvcGUuZHJhZnRzXy5mb3JFYWNoKHJldm9rZURyYWZ0KTtcbiAgc2NvcGUuZHJhZnRzXyA9IG51bGw7XG59XG5mdW5jdGlvbiBsZWF2ZVNjb3BlKHNjb3BlKSB7XG4gIGlmIChzY29wZSA9PT0gY3VycmVudFNjb3BlKSB7XG4gICAgY3VycmVudFNjb3BlID0gc2NvcGUucGFyZW50XztcbiAgfVxufVxuZnVuY3Rpb24gZW50ZXJTY29wZShpbW1lcjIpIHtcbiAgcmV0dXJuIGN1cnJlbnRTY29wZSA9IGNyZWF0ZVNjb3BlKGN1cnJlbnRTY29wZSwgaW1tZXIyKTtcbn1cbmZ1bmN0aW9uIHJldm9rZURyYWZ0KGRyYWZ0KSB7XG4gIGNvbnN0IHN0YXRlID0gZHJhZnRbRFJBRlRfU1RBVEVdO1xuICBpZiAoc3RhdGUudHlwZV8gPT09IDAgLyogT2JqZWN0ICovIHx8IHN0YXRlLnR5cGVfID09PSAxIC8qIEFycmF5ICovKVxuICAgIHN0YXRlLnJldm9rZV8oKTtcbiAgZWxzZVxuICAgIHN0YXRlLnJldm9rZWRfID0gdHJ1ZTtcbn1cblxuLy8gc3JjL2NvcmUvZmluYWxpemUudHNcbmZ1bmN0aW9uIHByb2Nlc3NSZXN1bHQocmVzdWx0LCBzY29wZSkge1xuICBzY29wZS51bmZpbmFsaXplZERyYWZ0c18gPSBzY29wZS5kcmFmdHNfLmxlbmd0aDtcbiAgY29uc3QgYmFzZURyYWZ0ID0gc2NvcGUuZHJhZnRzX1swXTtcbiAgY29uc3QgaXNSZXBsYWNlZCA9IHJlc3VsdCAhPT0gdm9pZCAwICYmIHJlc3VsdCAhPT0gYmFzZURyYWZ0O1xuICBpZiAoaXNSZXBsYWNlZCkge1xuICAgIGlmIChiYXNlRHJhZnRbRFJBRlRfU1RBVEVdLm1vZGlmaWVkXykge1xuICAgICAgcmV2b2tlU2NvcGUoc2NvcGUpO1xuICAgICAgZGllKDQpO1xuICAgIH1cbiAgICBpZiAoaXNEcmFmdGFibGUocmVzdWx0KSkge1xuICAgICAgcmVzdWx0ID0gZmluYWxpemUoc2NvcGUsIHJlc3VsdCk7XG4gICAgICBpZiAoIXNjb3BlLnBhcmVudF8pXG4gICAgICAgIG1heWJlRnJlZXplKHNjb3BlLCByZXN1bHQpO1xuICAgIH1cbiAgICBpZiAoc2NvcGUucGF0Y2hlc18pIHtcbiAgICAgIGdldFBsdWdpbihcIlBhdGNoZXNcIikuZ2VuZXJhdGVSZXBsYWNlbWVudFBhdGNoZXNfKFxuICAgICAgICBiYXNlRHJhZnRbRFJBRlRfU1RBVEVdLmJhc2VfLFxuICAgICAgICByZXN1bHQsXG4gICAgICAgIHNjb3BlLnBhdGNoZXNfLFxuICAgICAgICBzY29wZS5pbnZlcnNlUGF0Y2hlc19cbiAgICAgICk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHJlc3VsdCA9IGZpbmFsaXplKHNjb3BlLCBiYXNlRHJhZnQsIFtdKTtcbiAgfVxuICByZXZva2VTY29wZShzY29wZSk7XG4gIGlmIChzY29wZS5wYXRjaGVzXykge1xuICAgIHNjb3BlLnBhdGNoTGlzdGVuZXJfKHNjb3BlLnBhdGNoZXNfLCBzY29wZS5pbnZlcnNlUGF0Y2hlc18pO1xuICB9XG4gIHJldHVybiByZXN1bHQgIT09IE5PVEhJTkcgPyByZXN1bHQgOiB2b2lkIDA7XG59XG5mdW5jdGlvbiBmaW5hbGl6ZShyb290U2NvcGUsIHZhbHVlLCBwYXRoKSB7XG4gIGlmIChpc0Zyb3plbih2YWx1ZSkpXG4gICAgcmV0dXJuIHZhbHVlO1xuICBjb25zdCB1c2VTdHJpY3RJdGVyYXRpb24gPSByb290U2NvcGUuaW1tZXJfLnNob3VsZFVzZVN0cmljdEl0ZXJhdGlvbigpO1xuICBjb25zdCBzdGF0ZSA9IHZhbHVlW0RSQUZUX1NUQVRFXTtcbiAgaWYgKCFzdGF0ZSkge1xuICAgIGVhY2goXG4gICAgICB2YWx1ZSxcbiAgICAgIChrZXksIGNoaWxkVmFsdWUpID0+IGZpbmFsaXplUHJvcGVydHkocm9vdFNjb3BlLCBzdGF0ZSwgdmFsdWUsIGtleSwgY2hpbGRWYWx1ZSwgcGF0aCksXG4gICAgICB1c2VTdHJpY3RJdGVyYXRpb25cbiAgICApO1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxuICBpZiAoc3RhdGUuc2NvcGVfICE9PSByb290U2NvcGUpXG4gICAgcmV0dXJuIHZhbHVlO1xuICBpZiAoIXN0YXRlLm1vZGlmaWVkXykge1xuICAgIG1heWJlRnJlZXplKHJvb3RTY29wZSwgc3RhdGUuYmFzZV8sIHRydWUpO1xuICAgIHJldHVybiBzdGF0ZS5iYXNlXztcbiAgfVxuICBpZiAoIXN0YXRlLmZpbmFsaXplZF8pIHtcbiAgICBzdGF0ZS5maW5hbGl6ZWRfID0gdHJ1ZTtcbiAgICBzdGF0ZS5zY29wZV8udW5maW5hbGl6ZWREcmFmdHNfLS07XG4gICAgY29uc3QgcmVzdWx0ID0gc3RhdGUuY29weV87XG4gICAgbGV0IHJlc3VsdEVhY2ggPSByZXN1bHQ7XG4gICAgbGV0IGlzU2V0MiA9IGZhbHNlO1xuICAgIGlmIChzdGF0ZS50eXBlXyA9PT0gMyAvKiBTZXQgKi8pIHtcbiAgICAgIHJlc3VsdEVhY2ggPSBuZXcgU2V0KHJlc3VsdCk7XG4gICAgICByZXN1bHQuY2xlYXIoKTtcbiAgICAgIGlzU2V0MiA9IHRydWU7XG4gICAgfVxuICAgIGVhY2goXG4gICAgICByZXN1bHRFYWNoLFxuICAgICAgKGtleSwgY2hpbGRWYWx1ZSkgPT4gZmluYWxpemVQcm9wZXJ0eShcbiAgICAgICAgcm9vdFNjb3BlLFxuICAgICAgICBzdGF0ZSxcbiAgICAgICAgcmVzdWx0LFxuICAgICAgICBrZXksXG4gICAgICAgIGNoaWxkVmFsdWUsXG4gICAgICAgIHBhdGgsXG4gICAgICAgIGlzU2V0MlxuICAgICAgKSxcbiAgICAgIHVzZVN0cmljdEl0ZXJhdGlvblxuICAgICk7XG4gICAgbWF5YmVGcmVlemUocm9vdFNjb3BlLCByZXN1bHQsIGZhbHNlKTtcbiAgICBpZiAocGF0aCAmJiByb290U2NvcGUucGF0Y2hlc18pIHtcbiAgICAgIGdldFBsdWdpbihcIlBhdGNoZXNcIikuZ2VuZXJhdGVQYXRjaGVzXyhcbiAgICAgICAgc3RhdGUsXG4gICAgICAgIHBhdGgsXG4gICAgICAgIHJvb3RTY29wZS5wYXRjaGVzXyxcbiAgICAgICAgcm9vdFNjb3BlLmludmVyc2VQYXRjaGVzX1xuICAgICAgKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHN0YXRlLmNvcHlfO1xufVxuZnVuY3Rpb24gZmluYWxpemVQcm9wZXJ0eShyb290U2NvcGUsIHBhcmVudFN0YXRlLCB0YXJnZXRPYmplY3QsIHByb3AsIGNoaWxkVmFsdWUsIHJvb3RQYXRoLCB0YXJnZXRJc1NldCkge1xuICBpZiAoY2hpbGRWYWx1ZSA9PSBudWxsKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGlmICh0eXBlb2YgY2hpbGRWYWx1ZSAhPT0gXCJvYmplY3RcIiAmJiAhdGFyZ2V0SXNTZXQpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgY29uc3QgY2hpbGRJc0Zyb3plbiA9IGlzRnJvemVuKGNoaWxkVmFsdWUpO1xuICBpZiAoY2hpbGRJc0Zyb3plbiAmJiAhdGFyZ2V0SXNTZXQpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiAmJiBjaGlsZFZhbHVlID09PSB0YXJnZXRPYmplY3QpXG4gICAgZGllKDUpO1xuICBpZiAoaXNEcmFmdChjaGlsZFZhbHVlKSkge1xuICAgIGNvbnN0IHBhdGggPSByb290UGF0aCAmJiBwYXJlbnRTdGF0ZSAmJiBwYXJlbnRTdGF0ZS50eXBlXyAhPT0gMyAvKiBTZXQgKi8gJiYgLy8gU2V0IG9iamVjdHMgYXJlIGF0b21pYyBzaW5jZSB0aGV5IGhhdmUgbm8ga2V5cy5cbiAgICAhaGFzKHBhcmVudFN0YXRlLmFzc2lnbmVkXywgcHJvcCkgPyByb290UGF0aC5jb25jYXQocHJvcCkgOiB2b2lkIDA7XG4gICAgY29uc3QgcmVzID0gZmluYWxpemUocm9vdFNjb3BlLCBjaGlsZFZhbHVlLCBwYXRoKTtcbiAgICBzZXQodGFyZ2V0T2JqZWN0LCBwcm9wLCByZXMpO1xuICAgIGlmIChpc0RyYWZ0KHJlcykpIHtcbiAgICAgIHJvb3RTY29wZS5jYW5BdXRvRnJlZXplXyA9IGZhbHNlO1xuICAgIH0gZWxzZVxuICAgICAgcmV0dXJuO1xuICB9IGVsc2UgaWYgKHRhcmdldElzU2V0KSB7XG4gICAgdGFyZ2V0T2JqZWN0LmFkZChjaGlsZFZhbHVlKTtcbiAgfVxuICBpZiAoaXNEcmFmdGFibGUoY2hpbGRWYWx1ZSkgJiYgIWNoaWxkSXNGcm96ZW4pIHtcbiAgICBpZiAoIXJvb3RTY29wZS5pbW1lcl8uYXV0b0ZyZWV6ZV8gJiYgcm9vdFNjb3BlLnVuZmluYWxpemVkRHJhZnRzXyA8IDEpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKHBhcmVudFN0YXRlICYmIHBhcmVudFN0YXRlLmJhc2VfICYmIHBhcmVudFN0YXRlLmJhc2VfW3Byb3BdID09PSBjaGlsZFZhbHVlICYmIGNoaWxkSXNGcm96ZW4pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZmluYWxpemUocm9vdFNjb3BlLCBjaGlsZFZhbHVlKTtcbiAgICBpZiAoKCFwYXJlbnRTdGF0ZSB8fCAhcGFyZW50U3RhdGUuc2NvcGVfLnBhcmVudF8pICYmIHR5cGVvZiBwcm9wICE9PSBcInN5bWJvbFwiICYmIChpc01hcCh0YXJnZXRPYmplY3QpID8gdGFyZ2V0T2JqZWN0Lmhhcyhwcm9wKSA6IE9iamVjdC5wcm90b3R5cGUucHJvcGVydHlJc0VudW1lcmFibGUuY2FsbCh0YXJnZXRPYmplY3QsIHByb3ApKSlcbiAgICAgIG1heWJlRnJlZXplKHJvb3RTY29wZSwgY2hpbGRWYWx1ZSk7XG4gIH1cbn1cbmZ1bmN0aW9uIG1heWJlRnJlZXplKHNjb3BlLCB2YWx1ZSwgZGVlcCA9IGZhbHNlKSB7XG4gIGlmICghc2NvcGUucGFyZW50XyAmJiBzY29wZS5pbW1lcl8uYXV0b0ZyZWV6ZV8gJiYgc2NvcGUuY2FuQXV0b0ZyZWV6ZV8pIHtcbiAgICBmcmVlemUodmFsdWUsIGRlZXApO1xuICB9XG59XG5cbi8vIHNyYy9jb3JlL3Byb3h5LnRzXG5mdW5jdGlvbiBjcmVhdGVQcm94eVByb3h5KGJhc2UsIHBhcmVudCkge1xuICBjb25zdCBpc0FycmF5ID0gQXJyYXkuaXNBcnJheShiYXNlKTtcbiAgY29uc3Qgc3RhdGUgPSB7XG4gICAgdHlwZV86IGlzQXJyYXkgPyAxIC8qIEFycmF5ICovIDogMCAvKiBPYmplY3QgKi8sXG4gICAgLy8gVHJhY2sgd2hpY2ggcHJvZHVjZSBjYWxsIHRoaXMgaXMgYXNzb2NpYXRlZCB3aXRoLlxuICAgIHNjb3BlXzogcGFyZW50ID8gcGFyZW50LnNjb3BlXyA6IGdldEN1cnJlbnRTY29wZSgpLFxuICAgIC8vIFRydWUgZm9yIGJvdGggc2hhbGxvdyBhbmQgZGVlcCBjaGFuZ2VzLlxuICAgIG1vZGlmaWVkXzogZmFsc2UsXG4gICAgLy8gVXNlZCBkdXJpbmcgZmluYWxpemF0aW9uLlxuICAgIGZpbmFsaXplZF86IGZhbHNlLFxuICAgIC8vIFRyYWNrIHdoaWNoIHByb3BlcnRpZXMgaGF2ZSBiZWVuIGFzc2lnbmVkICh0cnVlKSBvciBkZWxldGVkIChmYWxzZSkuXG4gICAgYXNzaWduZWRfOiB7fSxcbiAgICAvLyBUaGUgcGFyZW50IGRyYWZ0IHN0YXRlLlxuICAgIHBhcmVudF86IHBhcmVudCxcbiAgICAvLyBUaGUgYmFzZSBzdGF0ZS5cbiAgICBiYXNlXzogYmFzZSxcbiAgICAvLyBUaGUgYmFzZSBwcm94eS5cbiAgICBkcmFmdF86IG51bGwsXG4gICAgLy8gc2V0IGJlbG93XG4gICAgLy8gVGhlIGJhc2UgY29weSB3aXRoIGFueSB1cGRhdGVkIHZhbHVlcy5cbiAgICBjb3B5XzogbnVsbCxcbiAgICAvLyBDYWxsZWQgYnkgdGhlIGBwcm9kdWNlYCBmdW5jdGlvbi5cbiAgICByZXZva2VfOiBudWxsLFxuICAgIGlzTWFudWFsXzogZmFsc2VcbiAgfTtcbiAgbGV0IHRhcmdldCA9IHN0YXRlO1xuICBsZXQgdHJhcHMgPSBvYmplY3RUcmFwcztcbiAgaWYgKGlzQXJyYXkpIHtcbiAgICB0YXJnZXQgPSBbc3RhdGVdO1xuICAgIHRyYXBzID0gYXJyYXlUcmFwcztcbiAgfVxuICBjb25zdCB7IHJldm9rZSwgcHJveHkgfSA9IFByb3h5LnJldm9jYWJsZSh0YXJnZXQsIHRyYXBzKTtcbiAgc3RhdGUuZHJhZnRfID0gcHJveHk7XG4gIHN0YXRlLnJldm9rZV8gPSByZXZva2U7XG4gIHJldHVybiBwcm94eTtcbn1cbnZhciBvYmplY3RUcmFwcyA9IHtcbiAgZ2V0KHN0YXRlLCBwcm9wKSB7XG4gICAgaWYgKHByb3AgPT09IERSQUZUX1NUQVRFKVxuICAgICAgcmV0dXJuIHN0YXRlO1xuICAgIGNvbnN0IHNvdXJjZSA9IGxhdGVzdChzdGF0ZSk7XG4gICAgaWYgKCFoYXMoc291cmNlLCBwcm9wKSkge1xuICAgICAgcmV0dXJuIHJlYWRQcm9wRnJvbVByb3RvKHN0YXRlLCBzb3VyY2UsIHByb3ApO1xuICAgIH1cbiAgICBjb25zdCB2YWx1ZSA9IHNvdXJjZVtwcm9wXTtcbiAgICBpZiAoc3RhdGUuZmluYWxpemVkXyB8fCAhaXNEcmFmdGFibGUodmFsdWUpKSB7XG4gICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuICAgIGlmICh2YWx1ZSA9PT0gcGVlayhzdGF0ZS5iYXNlXywgcHJvcCkpIHtcbiAgICAgIHByZXBhcmVDb3B5KHN0YXRlKTtcbiAgICAgIHJldHVybiBzdGF0ZS5jb3B5X1twcm9wXSA9IGNyZWF0ZVByb3h5KHZhbHVlLCBzdGF0ZSk7XG4gICAgfVxuICAgIHJldHVybiB2YWx1ZTtcbiAgfSxcbiAgaGFzKHN0YXRlLCBwcm9wKSB7XG4gICAgcmV0dXJuIHByb3AgaW4gbGF0ZXN0KHN0YXRlKTtcbiAgfSxcbiAgb3duS2V5cyhzdGF0ZSkge1xuICAgIHJldHVybiBSZWZsZWN0Lm93bktleXMobGF0ZXN0KHN0YXRlKSk7XG4gIH0sXG4gIHNldChzdGF0ZSwgcHJvcCwgdmFsdWUpIHtcbiAgICBjb25zdCBkZXNjID0gZ2V0RGVzY3JpcHRvckZyb21Qcm90byhsYXRlc3Qoc3RhdGUpLCBwcm9wKTtcbiAgICBpZiAoZGVzYz8uc2V0KSB7XG4gICAgICBkZXNjLnNldC5jYWxsKHN0YXRlLmRyYWZ0XywgdmFsdWUpO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGlmICghc3RhdGUubW9kaWZpZWRfKSB7XG4gICAgICBjb25zdCBjdXJyZW50MiA9IHBlZWsobGF0ZXN0KHN0YXRlKSwgcHJvcCk7XG4gICAgICBjb25zdCBjdXJyZW50U3RhdGUgPSBjdXJyZW50Mj8uW0RSQUZUX1NUQVRFXTtcbiAgICAgIGlmIChjdXJyZW50U3RhdGUgJiYgY3VycmVudFN0YXRlLmJhc2VfID09PSB2YWx1ZSkge1xuICAgICAgICBzdGF0ZS5jb3B5X1twcm9wXSA9IHZhbHVlO1xuICAgICAgICBzdGF0ZS5hc3NpZ25lZF9bcHJvcF0gPSBmYWxzZTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgICBpZiAoaXModmFsdWUsIGN1cnJlbnQyKSAmJiAodmFsdWUgIT09IHZvaWQgMCB8fCBoYXMoc3RhdGUuYmFzZV8sIHByb3ApKSlcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICBwcmVwYXJlQ29weShzdGF0ZSk7XG4gICAgICBtYXJrQ2hhbmdlZChzdGF0ZSk7XG4gICAgfVxuICAgIGlmIChzdGF0ZS5jb3B5X1twcm9wXSA9PT0gdmFsdWUgJiYgLy8gc3BlY2lhbCBjYXNlOiBoYW5kbGUgbmV3IHByb3BzIHdpdGggdmFsdWUgJ3VuZGVmaW5lZCdcbiAgICAodmFsdWUgIT09IHZvaWQgMCB8fCBwcm9wIGluIHN0YXRlLmNvcHlfKSB8fCAvLyBzcGVjaWFsIGNhc2U6IE5hTlxuICAgIE51bWJlci5pc05hTih2YWx1ZSkgJiYgTnVtYmVyLmlzTmFOKHN0YXRlLmNvcHlfW3Byb3BdKSlcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIHN0YXRlLmNvcHlfW3Byb3BdID0gdmFsdWU7XG4gICAgc3RhdGUuYXNzaWduZWRfW3Byb3BdID0gdHJ1ZTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSxcbiAgZGVsZXRlUHJvcGVydHkoc3RhdGUsIHByb3ApIHtcbiAgICBpZiAocGVlayhzdGF0ZS5iYXNlXywgcHJvcCkgIT09IHZvaWQgMCB8fCBwcm9wIGluIHN0YXRlLmJhc2VfKSB7XG4gICAgICBzdGF0ZS5hc3NpZ25lZF9bcHJvcF0gPSBmYWxzZTtcbiAgICAgIHByZXBhcmVDb3B5KHN0YXRlKTtcbiAgICAgIG1hcmtDaGFuZ2VkKHN0YXRlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZGVsZXRlIHN0YXRlLmFzc2lnbmVkX1twcm9wXTtcbiAgICB9XG4gICAgaWYgKHN0YXRlLmNvcHlfKSB7XG4gICAgICBkZWxldGUgc3RhdGUuY29weV9bcHJvcF07XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xuICB9LFxuICAvLyBOb3RlOiBXZSBuZXZlciBjb2VyY2UgYGRlc2MudmFsdWVgIGludG8gYW4gSW1tZXIgZHJhZnQsIGJlY2F1c2Ugd2UgY2FuJ3QgbWFrZVxuICAvLyB0aGUgc2FtZSBndWFyYW50ZWUgaW4gRVM1IG1vZGUuXG4gIGdldE93blByb3BlcnR5RGVzY3JpcHRvcihzdGF0ZSwgcHJvcCkge1xuICAgIGNvbnN0IG93bmVyID0gbGF0ZXN0KHN0YXRlKTtcbiAgICBjb25zdCBkZXNjID0gUmVmbGVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob3duZXIsIHByb3ApO1xuICAgIGlmICghZGVzYylcbiAgICAgIHJldHVybiBkZXNjO1xuICAgIHJldHVybiB7XG4gICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgIGNvbmZpZ3VyYWJsZTogc3RhdGUudHlwZV8gIT09IDEgLyogQXJyYXkgKi8gfHwgcHJvcCAhPT0gXCJsZW5ndGhcIixcbiAgICAgIGVudW1lcmFibGU6IGRlc2MuZW51bWVyYWJsZSxcbiAgICAgIHZhbHVlOiBvd25lcltwcm9wXVxuICAgIH07XG4gIH0sXG4gIGRlZmluZVByb3BlcnR5KCkge1xuICAgIGRpZSgxMSk7XG4gIH0sXG4gIGdldFByb3RvdHlwZU9mKHN0YXRlKSB7XG4gICAgcmV0dXJuIGdldFByb3RvdHlwZU9mKHN0YXRlLmJhc2VfKTtcbiAgfSxcbiAgc2V0UHJvdG90eXBlT2YoKSB7XG4gICAgZGllKDEyKTtcbiAgfVxufTtcbnZhciBhcnJheVRyYXBzID0ge307XG5lYWNoKG9iamVjdFRyYXBzLCAoa2V5LCBmbikgPT4ge1xuICBhcnJheVRyYXBzW2tleV0gPSBmdW5jdGlvbigpIHtcbiAgICBhcmd1bWVudHNbMF0gPSBhcmd1bWVudHNbMF1bMF07XG4gICAgcmV0dXJuIGZuLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gIH07XG59KTtcbmFycmF5VHJhcHMuZGVsZXRlUHJvcGVydHkgPSBmdW5jdGlvbihzdGF0ZSwgcHJvcCkge1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiICYmIGlzTmFOKHBhcnNlSW50KHByb3ApKSlcbiAgICBkaWUoMTMpO1xuICByZXR1cm4gYXJyYXlUcmFwcy5zZXQuY2FsbCh0aGlzLCBzdGF0ZSwgcHJvcCwgdm9pZCAwKTtcbn07XG5hcnJheVRyYXBzLnNldCA9IGZ1bmN0aW9uKHN0YXRlLCBwcm9wLCB2YWx1ZSkge1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiICYmIHByb3AgIT09IFwibGVuZ3RoXCIgJiYgaXNOYU4ocGFyc2VJbnQocHJvcCkpKVxuICAgIGRpZSgxNCk7XG4gIHJldHVybiBvYmplY3RUcmFwcy5zZXQuY2FsbCh0aGlzLCBzdGF0ZVswXSwgcHJvcCwgdmFsdWUsIHN0YXRlWzBdKTtcbn07XG5mdW5jdGlvbiBwZWVrKGRyYWZ0LCBwcm9wKSB7XG4gIGNvbnN0IHN0YXRlID0gZHJhZnRbRFJBRlRfU1RBVEVdO1xuICBjb25zdCBzb3VyY2UgPSBzdGF0ZSA/IGxhdGVzdChzdGF0ZSkgOiBkcmFmdDtcbiAgcmV0dXJuIHNvdXJjZVtwcm9wXTtcbn1cbmZ1bmN0aW9uIHJlYWRQcm9wRnJvbVByb3RvKHN0YXRlLCBzb3VyY2UsIHByb3ApIHtcbiAgY29uc3QgZGVzYyA9IGdldERlc2NyaXB0b3JGcm9tUHJvdG8oc291cmNlLCBwcm9wKTtcbiAgcmV0dXJuIGRlc2MgPyBgdmFsdWVgIGluIGRlc2MgPyBkZXNjLnZhbHVlIDogKFxuICAgIC8vIFRoaXMgaXMgYSB2ZXJ5IHNwZWNpYWwgY2FzZSwgaWYgdGhlIHByb3AgaXMgYSBnZXR0ZXIgZGVmaW5lZCBieSB0aGVcbiAgICAvLyBwcm90b3R5cGUsIHdlIHNob3VsZCBpbnZva2UgaXQgd2l0aCB0aGUgZHJhZnQgYXMgY29udGV4dCFcbiAgICBkZXNjLmdldD8uY2FsbChzdGF0ZS5kcmFmdF8pXG4gICkgOiB2b2lkIDA7XG59XG5mdW5jdGlvbiBnZXREZXNjcmlwdG9yRnJvbVByb3RvKHNvdXJjZSwgcHJvcCkge1xuICBpZiAoIShwcm9wIGluIHNvdXJjZSkpXG4gICAgcmV0dXJuIHZvaWQgMDtcbiAgbGV0IHByb3RvID0gZ2V0UHJvdG90eXBlT2Yoc291cmNlKTtcbiAgd2hpbGUgKHByb3RvKSB7XG4gICAgY29uc3QgZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IocHJvdG8sIHByb3ApO1xuICAgIGlmIChkZXNjKVxuICAgICAgcmV0dXJuIGRlc2M7XG4gICAgcHJvdG8gPSBnZXRQcm90b3R5cGVPZihwcm90byk7XG4gIH1cbiAgcmV0dXJuIHZvaWQgMDtcbn1cbmZ1bmN0aW9uIG1hcmtDaGFuZ2VkKHN0YXRlKSB7XG4gIGlmICghc3RhdGUubW9kaWZpZWRfKSB7XG4gICAgc3RhdGUubW9kaWZpZWRfID0gdHJ1ZTtcbiAgICBpZiAoc3RhdGUucGFyZW50Xykge1xuICAgICAgbWFya0NoYW5nZWQoc3RhdGUucGFyZW50Xyk7XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiBwcmVwYXJlQ29weShzdGF0ZSkge1xuICBpZiAoIXN0YXRlLmNvcHlfKSB7XG4gICAgc3RhdGUuY29weV8gPSBzaGFsbG93Q29weShcbiAgICAgIHN0YXRlLmJhc2VfLFxuICAgICAgc3RhdGUuc2NvcGVfLmltbWVyXy51c2VTdHJpY3RTaGFsbG93Q29weV9cbiAgICApO1xuICB9XG59XG5cbi8vIHNyYy9jb3JlL2ltbWVyQ2xhc3MudHNcbnZhciBJbW1lcjIgPSBjbGFzcyB7XG4gIGNvbnN0cnVjdG9yKGNvbmZpZykge1xuICAgIHRoaXMuYXV0b0ZyZWV6ZV8gPSB0cnVlO1xuICAgIHRoaXMudXNlU3RyaWN0U2hhbGxvd0NvcHlfID0gZmFsc2U7XG4gICAgdGhpcy51c2VTdHJpY3RJdGVyYXRpb25fID0gdHJ1ZTtcbiAgICAvKipcbiAgICAgKiBUaGUgYHByb2R1Y2VgIGZ1bmN0aW9uIHRha2VzIGEgdmFsdWUgYW5kIGEgXCJyZWNpcGUgZnVuY3Rpb25cIiAod2hvc2VcbiAgICAgKiByZXR1cm4gdmFsdWUgb2Z0ZW4gZGVwZW5kcyBvbiB0aGUgYmFzZSBzdGF0ZSkuIFRoZSByZWNpcGUgZnVuY3Rpb24gaXNcbiAgICAgKiBmcmVlIHRvIG11dGF0ZSBpdHMgZmlyc3QgYXJndW1lbnQgaG93ZXZlciBpdCB3YW50cy4gQWxsIG11dGF0aW9ucyBhcmVcbiAgICAgKiBvbmx5IGV2ZXIgYXBwbGllZCB0byBhIF9fY29weV9fIG9mIHRoZSBiYXNlIHN0YXRlLlxuICAgICAqXG4gICAgICogUGFzcyBvbmx5IGEgZnVuY3Rpb24gdG8gY3JlYXRlIGEgXCJjdXJyaWVkIHByb2R1Y2VyXCIgd2hpY2ggcmVsaWV2ZXMgeW91XG4gICAgICogZnJvbSBwYXNzaW5nIHRoZSByZWNpcGUgZnVuY3Rpb24gZXZlcnkgdGltZS5cbiAgICAgKlxuICAgICAqIE9ubHkgcGxhaW4gb2JqZWN0cyBhbmQgYXJyYXlzIGFyZSBtYWRlIG11dGFibGUuIEFsbCBvdGhlciBvYmplY3RzIGFyZVxuICAgICAqIGNvbnNpZGVyZWQgdW5jb3B5YWJsZS5cbiAgICAgKlxuICAgICAqIE5vdGU6IFRoaXMgZnVuY3Rpb24gaXMgX19ib3VuZF9fIHRvIGl0cyBgSW1tZXJgIGluc3RhbmNlLlxuICAgICAqXG4gICAgICogQHBhcmFtIHthbnl9IGJhc2UgLSB0aGUgaW5pdGlhbCBzdGF0ZVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IHJlY2lwZSAtIGZ1bmN0aW9uIHRoYXQgcmVjZWl2ZXMgYSBwcm94eSBvZiB0aGUgYmFzZSBzdGF0ZSBhcyBmaXJzdCBhcmd1bWVudCBhbmQgd2hpY2ggY2FuIGJlIGZyZWVseSBtb2RpZmllZFxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IHBhdGNoTGlzdGVuZXIgLSBvcHRpb25hbCBmdW5jdGlvbiB0aGF0IHdpbGwgYmUgY2FsbGVkIHdpdGggYWxsIHRoZSBwYXRjaGVzIHByb2R1Y2VkIGhlcmVcbiAgICAgKiBAcmV0dXJucyB7YW55fSBhIG5ldyBzdGF0ZSwgb3IgdGhlIGluaXRpYWwgc3RhdGUgaWYgbm90aGluZyB3YXMgbW9kaWZpZWRcbiAgICAgKi9cbiAgICB0aGlzLnByb2R1Y2UgPSAoYmFzZSwgcmVjaXBlLCBwYXRjaExpc3RlbmVyKSA9PiB7XG4gICAgICBpZiAodHlwZW9mIGJhc2UgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgcmVjaXBlICE9PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgY29uc3QgZGVmYXVsdEJhc2UgPSByZWNpcGU7XG4gICAgICAgIHJlY2lwZSA9IGJhc2U7XG4gICAgICAgIGNvbnN0IHNlbGYgPSB0aGlzO1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gY3VycmllZFByb2R1Y2UoYmFzZTIgPSBkZWZhdWx0QmFzZSwgLi4uYXJncykge1xuICAgICAgICAgIHJldHVybiBzZWxmLnByb2R1Y2UoYmFzZTIsIChkcmFmdCkgPT4gcmVjaXBlLmNhbGwodGhpcywgZHJhZnQsIC4uLmFyZ3MpKTtcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICAgIGlmICh0eXBlb2YgcmVjaXBlICE9PSBcImZ1bmN0aW9uXCIpXG4gICAgICAgIGRpZSg2KTtcbiAgICAgIGlmIChwYXRjaExpc3RlbmVyICE9PSB2b2lkIDAgJiYgdHlwZW9mIHBhdGNoTGlzdGVuZXIgIT09IFwiZnVuY3Rpb25cIilcbiAgICAgICAgZGllKDcpO1xuICAgICAgbGV0IHJlc3VsdDtcbiAgICAgIGlmIChpc0RyYWZ0YWJsZShiYXNlKSkge1xuICAgICAgICBjb25zdCBzY29wZSA9IGVudGVyU2NvcGUodGhpcyk7XG4gICAgICAgIGNvbnN0IHByb3h5ID0gY3JlYXRlUHJveHkoYmFzZSwgdm9pZCAwKTtcbiAgICAgICAgbGV0IGhhc0Vycm9yID0gdHJ1ZTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICByZXN1bHQgPSByZWNpcGUocHJveHkpO1xuICAgICAgICAgIGhhc0Vycm9yID0gZmFsc2U7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgaWYgKGhhc0Vycm9yKVxuICAgICAgICAgICAgcmV2b2tlU2NvcGUoc2NvcGUpO1xuICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgIGxlYXZlU2NvcGUoc2NvcGUpO1xuICAgICAgICB9XG4gICAgICAgIHVzZVBhdGNoZXNJblNjb3BlKHNjb3BlLCBwYXRjaExpc3RlbmVyKTtcbiAgICAgICAgcmV0dXJuIHByb2Nlc3NSZXN1bHQocmVzdWx0LCBzY29wZSk7XG4gICAgICB9IGVsc2UgaWYgKCFiYXNlIHx8IHR5cGVvZiBiYXNlICE9PSBcIm9iamVjdFwiKSB7XG4gICAgICAgIHJlc3VsdCA9IHJlY2lwZShiYXNlKTtcbiAgICAgICAgaWYgKHJlc3VsdCA9PT0gdm9pZCAwKVxuICAgICAgICAgIHJlc3VsdCA9IGJhc2U7XG4gICAgICAgIGlmIChyZXN1bHQgPT09IE5PVEhJTkcpXG4gICAgICAgICAgcmVzdWx0ID0gdm9pZCAwO1xuICAgICAgICBpZiAodGhpcy5hdXRvRnJlZXplXylcbiAgICAgICAgICBmcmVlemUocmVzdWx0LCB0cnVlKTtcbiAgICAgICAgaWYgKHBhdGNoTGlzdGVuZXIpIHtcbiAgICAgICAgICBjb25zdCBwID0gW107XG4gICAgICAgICAgY29uc3QgaXAgPSBbXTtcbiAgICAgICAgICBnZXRQbHVnaW4oXCJQYXRjaGVzXCIpLmdlbmVyYXRlUmVwbGFjZW1lbnRQYXRjaGVzXyhiYXNlLCByZXN1bHQsIHAsIGlwKTtcbiAgICAgICAgICBwYXRjaExpc3RlbmVyKHAsIGlwKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgfSBlbHNlXG4gICAgICAgIGRpZSgxLCBiYXNlKTtcbiAgICB9O1xuICAgIHRoaXMucHJvZHVjZVdpdGhQYXRjaGVzID0gKGJhc2UsIHJlY2lwZSkgPT4ge1xuICAgICAgaWYgKHR5cGVvZiBiYXNlID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgcmV0dXJuIChzdGF0ZSwgLi4uYXJncykgPT4gdGhpcy5wcm9kdWNlV2l0aFBhdGNoZXMoc3RhdGUsIChkcmFmdCkgPT4gYmFzZShkcmFmdCwgLi4uYXJncykpO1xuICAgICAgfVxuICAgICAgbGV0IHBhdGNoZXMsIGludmVyc2VQYXRjaGVzO1xuICAgICAgY29uc3QgcmVzdWx0ID0gdGhpcy5wcm9kdWNlKGJhc2UsIHJlY2lwZSwgKHAsIGlwKSA9PiB7XG4gICAgICAgIHBhdGNoZXMgPSBwO1xuICAgICAgICBpbnZlcnNlUGF0Y2hlcyA9IGlwO1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gW3Jlc3VsdCwgcGF0Y2hlcywgaW52ZXJzZVBhdGNoZXNdO1xuICAgIH07XG4gICAgaWYgKHR5cGVvZiBjb25maWc/LmF1dG9GcmVlemUgPT09IFwiYm9vbGVhblwiKVxuICAgICAgdGhpcy5zZXRBdXRvRnJlZXplKGNvbmZpZy5hdXRvRnJlZXplKTtcbiAgICBpZiAodHlwZW9mIGNvbmZpZz8udXNlU3RyaWN0U2hhbGxvd0NvcHkgPT09IFwiYm9vbGVhblwiKVxuICAgICAgdGhpcy5zZXRVc2VTdHJpY3RTaGFsbG93Q29weShjb25maWcudXNlU3RyaWN0U2hhbGxvd0NvcHkpO1xuICAgIGlmICh0eXBlb2YgY29uZmlnPy51c2VTdHJpY3RJdGVyYXRpb24gPT09IFwiYm9vbGVhblwiKVxuICAgICAgdGhpcy5zZXRVc2VTdHJpY3RJdGVyYXRpb24oY29uZmlnLnVzZVN0cmljdEl0ZXJhdGlvbik7XG4gIH1cbiAgY3JlYXRlRHJhZnQoYmFzZSkge1xuICAgIGlmICghaXNEcmFmdGFibGUoYmFzZSkpXG4gICAgICBkaWUoOCk7XG4gICAgaWYgKGlzRHJhZnQoYmFzZSkpXG4gICAgICBiYXNlID0gY3VycmVudChiYXNlKTtcbiAgICBjb25zdCBzY29wZSA9IGVudGVyU2NvcGUodGhpcyk7XG4gICAgY29uc3QgcHJveHkgPSBjcmVhdGVQcm94eShiYXNlLCB2b2lkIDApO1xuICAgIHByb3h5W0RSQUZUX1NUQVRFXS5pc01hbnVhbF8gPSB0cnVlO1xuICAgIGxlYXZlU2NvcGUoc2NvcGUpO1xuICAgIHJldHVybiBwcm94eTtcbiAgfVxuICBmaW5pc2hEcmFmdChkcmFmdCwgcGF0Y2hMaXN0ZW5lcikge1xuICAgIGNvbnN0IHN0YXRlID0gZHJhZnQgJiYgZHJhZnRbRFJBRlRfU1RBVEVdO1xuICAgIGlmICghc3RhdGUgfHwgIXN0YXRlLmlzTWFudWFsXylcbiAgICAgIGRpZSg5KTtcbiAgICBjb25zdCB7IHNjb3BlXzogc2NvcGUgfSA9IHN0YXRlO1xuICAgIHVzZVBhdGNoZXNJblNjb3BlKHNjb3BlLCBwYXRjaExpc3RlbmVyKTtcbiAgICByZXR1cm4gcHJvY2Vzc1Jlc3VsdCh2b2lkIDAsIHNjb3BlKTtcbiAgfVxuICAvKipcbiAgICogUGFzcyB0cnVlIHRvIGF1dG9tYXRpY2FsbHkgZnJlZXplIGFsbCBjb3BpZXMgY3JlYXRlZCBieSBJbW1lci5cbiAgICpcbiAgICogQnkgZGVmYXVsdCwgYXV0by1mcmVlemluZyBpcyBlbmFibGVkLlxuICAgKi9cbiAgc2V0QXV0b0ZyZWV6ZSh2YWx1ZSkge1xuICAgIHRoaXMuYXV0b0ZyZWV6ZV8gPSB2YWx1ZTtcbiAgfVxuICAvKipcbiAgICogUGFzcyB0cnVlIHRvIGVuYWJsZSBzdHJpY3Qgc2hhbGxvdyBjb3B5LlxuICAgKlxuICAgKiBCeSBkZWZhdWx0LCBpbW1lciBkb2VzIG5vdCBjb3B5IHRoZSBvYmplY3QgZGVzY3JpcHRvcnMgc3VjaCBhcyBnZXR0ZXIsIHNldHRlciBhbmQgbm9uLWVudW1yYWJsZSBwcm9wZXJ0aWVzLlxuICAgKi9cbiAgc2V0VXNlU3RyaWN0U2hhbGxvd0NvcHkodmFsdWUpIHtcbiAgICB0aGlzLnVzZVN0cmljdFNoYWxsb3dDb3B5XyA9IHZhbHVlO1xuICB9XG4gIC8qKlxuICAgKiBQYXNzIGZhbHNlIHRvIHVzZSBmYXN0ZXIgaXRlcmF0aW9uIHRoYXQgc2tpcHMgbm9uLWVudW1lcmFibGUgcHJvcGVydGllc1xuICAgKiBidXQgc3RpbGwgaGFuZGxlcyBzeW1ib2xzIGZvciBjb21wYXRpYmlsaXR5LlxuICAgKlxuICAgKiBCeSBkZWZhdWx0LCBzdHJpY3QgaXRlcmF0aW9uIGlzIGVuYWJsZWQgKGluY2x1ZGVzIGFsbCBvd24gcHJvcGVydGllcykuXG4gICAqL1xuICBzZXRVc2VTdHJpY3RJdGVyYXRpb24odmFsdWUpIHtcbiAgICB0aGlzLnVzZVN0cmljdEl0ZXJhdGlvbl8gPSB2YWx1ZTtcbiAgfVxuICBzaG91bGRVc2VTdHJpY3RJdGVyYXRpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMudXNlU3RyaWN0SXRlcmF0aW9uXztcbiAgfVxuICBhcHBseVBhdGNoZXMoYmFzZSwgcGF0Y2hlcykge1xuICAgIGxldCBpO1xuICAgIGZvciAoaSA9IHBhdGNoZXMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgIGNvbnN0IHBhdGNoID0gcGF0Y2hlc1tpXTtcbiAgICAgIGlmIChwYXRjaC5wYXRoLmxlbmd0aCA9PT0gMCAmJiBwYXRjaC5vcCA9PT0gXCJyZXBsYWNlXCIpIHtcbiAgICAgICAgYmFzZSA9IHBhdGNoLnZhbHVlO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGkgPiAtMSkge1xuICAgICAgcGF0Y2hlcyA9IHBhdGNoZXMuc2xpY2UoaSArIDEpO1xuICAgIH1cbiAgICBjb25zdCBhcHBseVBhdGNoZXNJbXBsID0gZ2V0UGx1Z2luKFwiUGF0Y2hlc1wiKS5hcHBseVBhdGNoZXNfO1xuICAgIGlmIChpc0RyYWZ0KGJhc2UpKSB7XG4gICAgICByZXR1cm4gYXBwbHlQYXRjaGVzSW1wbChiYXNlLCBwYXRjaGVzKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMucHJvZHVjZShcbiAgICAgIGJhc2UsXG4gICAgICAoZHJhZnQpID0+IGFwcGx5UGF0Y2hlc0ltcGwoZHJhZnQsIHBhdGNoZXMpXG4gICAgKTtcbiAgfVxufTtcbmZ1bmN0aW9uIGNyZWF0ZVByb3h5KHZhbHVlLCBwYXJlbnQpIHtcbiAgY29uc3QgZHJhZnQgPSBpc01hcCh2YWx1ZSkgPyBnZXRQbHVnaW4oXCJNYXBTZXRcIikucHJveHlNYXBfKHZhbHVlLCBwYXJlbnQpIDogaXNTZXQodmFsdWUpID8gZ2V0UGx1Z2luKFwiTWFwU2V0XCIpLnByb3h5U2V0Xyh2YWx1ZSwgcGFyZW50KSA6IGNyZWF0ZVByb3h5UHJveHkodmFsdWUsIHBhcmVudCk7XG4gIGNvbnN0IHNjb3BlID0gcGFyZW50ID8gcGFyZW50LnNjb3BlXyA6IGdldEN1cnJlbnRTY29wZSgpO1xuICBzY29wZS5kcmFmdHNfLnB1c2goZHJhZnQpO1xuICByZXR1cm4gZHJhZnQ7XG59XG5cbi8vIHNyYy9jb3JlL2N1cnJlbnQudHNcbmZ1bmN0aW9uIGN1cnJlbnQodmFsdWUpIHtcbiAgaWYgKCFpc0RyYWZ0KHZhbHVlKSlcbiAgICBkaWUoMTAsIHZhbHVlKTtcbiAgcmV0dXJuIGN1cnJlbnRJbXBsKHZhbHVlKTtcbn1cbmZ1bmN0aW9uIGN1cnJlbnRJbXBsKHZhbHVlKSB7XG4gIGlmICghaXNEcmFmdGFibGUodmFsdWUpIHx8IGlzRnJvemVuKHZhbHVlKSlcbiAgICByZXR1cm4gdmFsdWU7XG4gIGNvbnN0IHN0YXRlID0gdmFsdWVbRFJBRlRfU1RBVEVdO1xuICBsZXQgY29weTtcbiAgbGV0IHN0cmljdCA9IHRydWU7XG4gIGlmIChzdGF0ZSkge1xuICAgIGlmICghc3RhdGUubW9kaWZpZWRfKVxuICAgICAgcmV0dXJuIHN0YXRlLmJhc2VfO1xuICAgIHN0YXRlLmZpbmFsaXplZF8gPSB0cnVlO1xuICAgIGNvcHkgPSBzaGFsbG93Q29weSh2YWx1ZSwgc3RhdGUuc2NvcGVfLmltbWVyXy51c2VTdHJpY3RTaGFsbG93Q29weV8pO1xuICAgIHN0cmljdCA9IHN0YXRlLnNjb3BlXy5pbW1lcl8uc2hvdWxkVXNlU3RyaWN0SXRlcmF0aW9uKCk7XG4gIH0gZWxzZSB7XG4gICAgY29weSA9IHNoYWxsb3dDb3B5KHZhbHVlLCB0cnVlKTtcbiAgfVxuICBlYWNoKFxuICAgIGNvcHksXG4gICAgKGtleSwgY2hpbGRWYWx1ZSkgPT4ge1xuICAgICAgc2V0KGNvcHksIGtleSwgY3VycmVudEltcGwoY2hpbGRWYWx1ZSkpO1xuICAgIH0sXG4gICAgc3RyaWN0XG4gICk7XG4gIGlmIChzdGF0ZSkge1xuICAgIHN0YXRlLmZpbmFsaXplZF8gPSBmYWxzZTtcbiAgfVxuICByZXR1cm4gY29weTtcbn1cblxuLy8gc3JjL3BsdWdpbnMvcGF0Y2hlcy50c1xuZnVuY3Rpb24gZW5hYmxlUGF0Y2hlcygpIHtcbiAgY29uc3QgZXJyb3JPZmZzZXQgPSAxNjtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAgIGVycm9ycy5wdXNoKFxuICAgICAgJ1NldHMgY2Fubm90IGhhdmUgXCJyZXBsYWNlXCIgcGF0Y2hlcy4nLFxuICAgICAgZnVuY3Rpb24ob3ApIHtcbiAgICAgICAgcmV0dXJuIFwiVW5zdXBwb3J0ZWQgcGF0Y2ggb3BlcmF0aW9uOiBcIiArIG9wO1xuICAgICAgfSxcbiAgICAgIGZ1bmN0aW9uKHBhdGgpIHtcbiAgICAgICAgcmV0dXJuIFwiQ2Fubm90IGFwcGx5IHBhdGNoLCBwYXRoIGRvZXNuJ3QgcmVzb2x2ZTogXCIgKyBwYXRoO1xuICAgICAgfSxcbiAgICAgIFwiUGF0Y2hpbmcgcmVzZXJ2ZWQgYXR0cmlidXRlcyBsaWtlIF9fcHJvdG9fXywgcHJvdG90eXBlIGFuZCBjb25zdHJ1Y3RvciBpcyBub3QgYWxsb3dlZFwiXG4gICAgKTtcbiAgfVxuICBjb25zdCBSRVBMQUNFID0gXCJyZXBsYWNlXCI7XG4gIGNvbnN0IEFERCA9IFwiYWRkXCI7XG4gIGNvbnN0IFJFTU9WRSA9IFwicmVtb3ZlXCI7XG4gIGZ1bmN0aW9uIGdlbmVyYXRlUGF0Y2hlc18oc3RhdGUsIGJhc2VQYXRoLCBwYXRjaGVzLCBpbnZlcnNlUGF0Y2hlcykge1xuICAgIHN3aXRjaCAoc3RhdGUudHlwZV8pIHtcbiAgICAgIGNhc2UgMCAvKiBPYmplY3QgKi86XG4gICAgICBjYXNlIDIgLyogTWFwICovOlxuICAgICAgICByZXR1cm4gZ2VuZXJhdGVQYXRjaGVzRnJvbUFzc2lnbmVkKFxuICAgICAgICAgIHN0YXRlLFxuICAgICAgICAgIGJhc2VQYXRoLFxuICAgICAgICAgIHBhdGNoZXMsXG4gICAgICAgICAgaW52ZXJzZVBhdGNoZXNcbiAgICAgICAgKTtcbiAgICAgIGNhc2UgMSAvKiBBcnJheSAqLzpcbiAgICAgICAgcmV0dXJuIGdlbmVyYXRlQXJyYXlQYXRjaGVzKHN0YXRlLCBiYXNlUGF0aCwgcGF0Y2hlcywgaW52ZXJzZVBhdGNoZXMpO1xuICAgICAgY2FzZSAzIC8qIFNldCAqLzpcbiAgICAgICAgcmV0dXJuIGdlbmVyYXRlU2V0UGF0Y2hlcyhcbiAgICAgICAgICBzdGF0ZSxcbiAgICAgICAgICBiYXNlUGF0aCxcbiAgICAgICAgICBwYXRjaGVzLFxuICAgICAgICAgIGludmVyc2VQYXRjaGVzXG4gICAgICAgICk7XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIGdlbmVyYXRlQXJyYXlQYXRjaGVzKHN0YXRlLCBiYXNlUGF0aCwgcGF0Y2hlcywgaW52ZXJzZVBhdGNoZXMpIHtcbiAgICBsZXQgeyBiYXNlXywgYXNzaWduZWRfIH0gPSBzdGF0ZTtcbiAgICBsZXQgY29weV8gPSBzdGF0ZS5jb3B5XztcbiAgICBpZiAoY29weV8ubGVuZ3RoIDwgYmFzZV8ubGVuZ3RoKSB7XG4gICAgICA7XG4gICAgICBbYmFzZV8sIGNvcHlfXSA9IFtjb3B5XywgYmFzZV9dO1xuICAgICAgW3BhdGNoZXMsIGludmVyc2VQYXRjaGVzXSA9IFtpbnZlcnNlUGF0Y2hlcywgcGF0Y2hlc107XG4gICAgfVxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYmFzZV8ubGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmIChhc3NpZ25lZF9baV0gJiYgY29weV9baV0gIT09IGJhc2VfW2ldKSB7XG4gICAgICAgIGNvbnN0IHBhdGggPSBiYXNlUGF0aC5jb25jYXQoW2ldKTtcbiAgICAgICAgcGF0Y2hlcy5wdXNoKHtcbiAgICAgICAgICBvcDogUkVQTEFDRSxcbiAgICAgICAgICBwYXRoLFxuICAgICAgICAgIC8vIE5lZWQgdG8gbWF5YmUgY2xvbmUgaXQsIGFzIGl0IGNhbiBpbiBmYWN0IGJlIHRoZSBvcmlnaW5hbCB2YWx1ZVxuICAgICAgICAgIC8vIGR1ZSB0byB0aGUgYmFzZS9jb3B5IGludmVyc2lvbiBhdCB0aGUgc3RhcnQgb2YgdGhpcyBmdW5jdGlvblxuICAgICAgICAgIHZhbHVlOiBjbG9uZVBhdGNoVmFsdWVJZk5lZWRlZChjb3B5X1tpXSlcbiAgICAgICAgfSk7XG4gICAgICAgIGludmVyc2VQYXRjaGVzLnB1c2goe1xuICAgICAgICAgIG9wOiBSRVBMQUNFLFxuICAgICAgICAgIHBhdGgsXG4gICAgICAgICAgdmFsdWU6IGNsb25lUGF0Y2hWYWx1ZUlmTmVlZGVkKGJhc2VfW2ldKVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG4gICAgZm9yIChsZXQgaSA9IGJhc2VfLmxlbmd0aDsgaSA8IGNvcHlfLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCBwYXRoID0gYmFzZVBhdGguY29uY2F0KFtpXSk7XG4gICAgICBwYXRjaGVzLnB1c2goe1xuICAgICAgICBvcDogQURELFxuICAgICAgICBwYXRoLFxuICAgICAgICAvLyBOZWVkIHRvIG1heWJlIGNsb25lIGl0LCBhcyBpdCBjYW4gaW4gZmFjdCBiZSB0aGUgb3JpZ2luYWwgdmFsdWVcbiAgICAgICAgLy8gZHVlIHRvIHRoZSBiYXNlL2NvcHkgaW52ZXJzaW9uIGF0IHRoZSBzdGFydCBvZiB0aGlzIGZ1bmN0aW9uXG4gICAgICAgIHZhbHVlOiBjbG9uZVBhdGNoVmFsdWVJZk5lZWRlZChjb3B5X1tpXSlcbiAgICAgIH0pO1xuICAgIH1cbiAgICBmb3IgKGxldCBpID0gY29weV8ubGVuZ3RoIC0gMTsgYmFzZV8ubGVuZ3RoIDw9IGk7IC0taSkge1xuICAgICAgY29uc3QgcGF0aCA9IGJhc2VQYXRoLmNvbmNhdChbaV0pO1xuICAgICAgaW52ZXJzZVBhdGNoZXMucHVzaCh7XG4gICAgICAgIG9wOiBSRU1PVkUsXG4gICAgICAgIHBhdGhcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuICBmdW5jdGlvbiBnZW5lcmF0ZVBhdGNoZXNGcm9tQXNzaWduZWQoc3RhdGUsIGJhc2VQYXRoLCBwYXRjaGVzLCBpbnZlcnNlUGF0Y2hlcykge1xuICAgIGNvbnN0IHsgYmFzZV8sIGNvcHlfIH0gPSBzdGF0ZTtcbiAgICBlYWNoKHN0YXRlLmFzc2lnbmVkXywgKGtleSwgYXNzaWduZWRWYWx1ZSkgPT4ge1xuICAgICAgY29uc3Qgb3JpZ1ZhbHVlID0gZ2V0KGJhc2VfLCBrZXkpO1xuICAgICAgY29uc3QgdmFsdWUgPSBnZXQoY29weV8sIGtleSk7XG4gICAgICBjb25zdCBvcCA9ICFhc3NpZ25lZFZhbHVlID8gUkVNT1ZFIDogaGFzKGJhc2VfLCBrZXkpID8gUkVQTEFDRSA6IEFERDtcbiAgICAgIGlmIChvcmlnVmFsdWUgPT09IHZhbHVlICYmIG9wID09PSBSRVBMQUNFKVxuICAgICAgICByZXR1cm47XG4gICAgICBjb25zdCBwYXRoID0gYmFzZVBhdGguY29uY2F0KGtleSk7XG4gICAgICBwYXRjaGVzLnB1c2gob3AgPT09IFJFTU9WRSA/IHsgb3AsIHBhdGggfSA6IHsgb3AsIHBhdGgsIHZhbHVlIH0pO1xuICAgICAgaW52ZXJzZVBhdGNoZXMucHVzaChcbiAgICAgICAgb3AgPT09IEFERCA/IHsgb3A6IFJFTU9WRSwgcGF0aCB9IDogb3AgPT09IFJFTU9WRSA/IHsgb3A6IEFERCwgcGF0aCwgdmFsdWU6IGNsb25lUGF0Y2hWYWx1ZUlmTmVlZGVkKG9yaWdWYWx1ZSkgfSA6IHsgb3A6IFJFUExBQ0UsIHBhdGgsIHZhbHVlOiBjbG9uZVBhdGNoVmFsdWVJZk5lZWRlZChvcmlnVmFsdWUpIH1cbiAgICAgICk7XG4gICAgfSk7XG4gIH1cbiAgZnVuY3Rpb24gZ2VuZXJhdGVTZXRQYXRjaGVzKHN0YXRlLCBiYXNlUGF0aCwgcGF0Y2hlcywgaW52ZXJzZVBhdGNoZXMpIHtcbiAgICBsZXQgeyBiYXNlXywgY29weV8gfSA9IHN0YXRlO1xuICAgIGxldCBpID0gMDtcbiAgICBiYXNlXy5mb3JFYWNoKCh2YWx1ZSkgPT4ge1xuICAgICAgaWYgKCFjb3B5Xy5oYXModmFsdWUpKSB7XG4gICAgICAgIGNvbnN0IHBhdGggPSBiYXNlUGF0aC5jb25jYXQoW2ldKTtcbiAgICAgICAgcGF0Y2hlcy5wdXNoKHtcbiAgICAgICAgICBvcDogUkVNT1ZFLFxuICAgICAgICAgIHBhdGgsXG4gICAgICAgICAgdmFsdWVcbiAgICAgICAgfSk7XG4gICAgICAgIGludmVyc2VQYXRjaGVzLnVuc2hpZnQoe1xuICAgICAgICAgIG9wOiBBREQsXG4gICAgICAgICAgcGF0aCxcbiAgICAgICAgICB2YWx1ZVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIGkrKztcbiAgICB9KTtcbiAgICBpID0gMDtcbiAgICBjb3B5Xy5mb3JFYWNoKCh2YWx1ZSkgPT4ge1xuICAgICAgaWYgKCFiYXNlXy5oYXModmFsdWUpKSB7XG4gICAgICAgIGNvbnN0IHBhdGggPSBiYXNlUGF0aC5jb25jYXQoW2ldKTtcbiAgICAgICAgcGF0Y2hlcy5wdXNoKHtcbiAgICAgICAgICBvcDogQURELFxuICAgICAgICAgIHBhdGgsXG4gICAgICAgICAgdmFsdWVcbiAgICAgICAgfSk7XG4gICAgICAgIGludmVyc2VQYXRjaGVzLnVuc2hpZnQoe1xuICAgICAgICAgIG9wOiBSRU1PVkUsXG4gICAgICAgICAgcGF0aCxcbiAgICAgICAgICB2YWx1ZVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIGkrKztcbiAgICB9KTtcbiAgfVxuICBmdW5jdGlvbiBnZW5lcmF0ZVJlcGxhY2VtZW50UGF0Y2hlc18oYmFzZVZhbHVlLCByZXBsYWNlbWVudCwgcGF0Y2hlcywgaW52ZXJzZVBhdGNoZXMpIHtcbiAgICBwYXRjaGVzLnB1c2goe1xuICAgICAgb3A6IFJFUExBQ0UsXG4gICAgICBwYXRoOiBbXSxcbiAgICAgIHZhbHVlOiByZXBsYWNlbWVudCA9PT0gTk9USElORyA/IHZvaWQgMCA6IHJlcGxhY2VtZW50XG4gICAgfSk7XG4gICAgaW52ZXJzZVBhdGNoZXMucHVzaCh7XG4gICAgICBvcDogUkVQTEFDRSxcbiAgICAgIHBhdGg6IFtdLFxuICAgICAgdmFsdWU6IGJhc2VWYWx1ZVxuICAgIH0pO1xuICB9XG4gIGZ1bmN0aW9uIGFwcGx5UGF0Y2hlc18oZHJhZnQsIHBhdGNoZXMpIHtcbiAgICBwYXRjaGVzLmZvckVhY2goKHBhdGNoKSA9PiB7XG4gICAgICBjb25zdCB7IHBhdGgsIG9wIH0gPSBwYXRjaDtcbiAgICAgIGxldCBiYXNlID0gZHJhZnQ7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHBhdGgubGVuZ3RoIC0gMTsgaSsrKSB7XG4gICAgICAgIGNvbnN0IHBhcmVudFR5cGUgPSBnZXRBcmNodHlwZShiYXNlKTtcbiAgICAgICAgbGV0IHAgPSBwYXRoW2ldO1xuICAgICAgICBpZiAodHlwZW9mIHAgIT09IFwic3RyaW5nXCIgJiYgdHlwZW9mIHAgIT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgICBwID0gXCJcIiArIHA7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKChwYXJlbnRUeXBlID09PSAwIC8qIE9iamVjdCAqLyB8fCBwYXJlbnRUeXBlID09PSAxIC8qIEFycmF5ICovKSAmJiAocCA9PT0gXCJfX3Byb3RvX19cIiB8fCBwID09PSBcImNvbnN0cnVjdG9yXCIpKVxuICAgICAgICAgIGRpZShlcnJvck9mZnNldCArIDMpO1xuICAgICAgICBpZiAodHlwZW9mIGJhc2UgPT09IFwiZnVuY3Rpb25cIiAmJiBwID09PSBcInByb3RvdHlwZVwiKVxuICAgICAgICAgIGRpZShlcnJvck9mZnNldCArIDMpO1xuICAgICAgICBiYXNlID0gZ2V0KGJhc2UsIHApO1xuICAgICAgICBpZiAodHlwZW9mIGJhc2UgIT09IFwib2JqZWN0XCIpXG4gICAgICAgICAgZGllKGVycm9yT2Zmc2V0ICsgMiwgcGF0aC5qb2luKFwiL1wiKSk7XG4gICAgICB9XG4gICAgICBjb25zdCB0eXBlID0gZ2V0QXJjaHR5cGUoYmFzZSk7XG4gICAgICBjb25zdCB2YWx1ZSA9IGRlZXBDbG9uZVBhdGNoVmFsdWUocGF0Y2gudmFsdWUpO1xuICAgICAgY29uc3Qga2V5ID0gcGF0aFtwYXRoLmxlbmd0aCAtIDFdO1xuICAgICAgc3dpdGNoIChvcCkge1xuICAgICAgICBjYXNlIFJFUExBQ0U6XG4gICAgICAgICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICAgICAgICBjYXNlIDIgLyogTWFwICovOlxuICAgICAgICAgICAgICByZXR1cm4gYmFzZS5zZXQoa2V5LCB2YWx1ZSk7XG4gICAgICAgICAgICBjYXNlIDMgLyogU2V0ICovOlxuICAgICAgICAgICAgICBkaWUoZXJyb3JPZmZzZXQpO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgcmV0dXJuIGJhc2Vba2V5XSA9IHZhbHVlO1xuICAgICAgICAgIH1cbiAgICAgICAgY2FzZSBBREQ6XG4gICAgICAgICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICAgICAgICBjYXNlIDEgLyogQXJyYXkgKi86XG4gICAgICAgICAgICAgIHJldHVybiBrZXkgPT09IFwiLVwiID8gYmFzZS5wdXNoKHZhbHVlKSA6IGJhc2Uuc3BsaWNlKGtleSwgMCwgdmFsdWUpO1xuICAgICAgICAgICAgY2FzZSAyIC8qIE1hcCAqLzpcbiAgICAgICAgICAgICAgcmV0dXJuIGJhc2Uuc2V0KGtleSwgdmFsdWUpO1xuICAgICAgICAgICAgY2FzZSAzIC8qIFNldCAqLzpcbiAgICAgICAgICAgICAgcmV0dXJuIGJhc2UuYWRkKHZhbHVlKTtcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgIHJldHVybiBiYXNlW2tleV0gPSB2YWx1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIGNhc2UgUkVNT1ZFOlxuICAgICAgICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgICAgICAgY2FzZSAxIC8qIEFycmF5ICovOlxuICAgICAgICAgICAgICByZXR1cm4gYmFzZS5zcGxpY2Uoa2V5LCAxKTtcbiAgICAgICAgICAgIGNhc2UgMiAvKiBNYXAgKi86XG4gICAgICAgICAgICAgIHJldHVybiBiYXNlLmRlbGV0ZShrZXkpO1xuICAgICAgICAgICAgY2FzZSAzIC8qIFNldCAqLzpcbiAgICAgICAgICAgICAgcmV0dXJuIGJhc2UuZGVsZXRlKHBhdGNoLnZhbHVlKTtcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgIHJldHVybiBkZWxldGUgYmFzZVtrZXldO1xuICAgICAgICAgIH1cbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICBkaWUoZXJyb3JPZmZzZXQgKyAxLCBvcCk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIGRyYWZ0O1xuICB9XG4gIGZ1bmN0aW9uIGRlZXBDbG9uZVBhdGNoVmFsdWUob2JqKSB7XG4gICAgaWYgKCFpc0RyYWZ0YWJsZShvYmopKVxuICAgICAgcmV0dXJuIG9iajtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShvYmopKVxuICAgICAgcmV0dXJuIG9iai5tYXAoZGVlcENsb25lUGF0Y2hWYWx1ZSk7XG4gICAgaWYgKGlzTWFwKG9iaikpXG4gICAgICByZXR1cm4gbmV3IE1hcChcbiAgICAgICAgQXJyYXkuZnJvbShvYmouZW50cmllcygpKS5tYXAoKFtrLCB2XSkgPT4gW2ssIGRlZXBDbG9uZVBhdGNoVmFsdWUodildKVxuICAgICAgKTtcbiAgICBpZiAoaXNTZXQob2JqKSlcbiAgICAgIHJldHVybiBuZXcgU2V0KEFycmF5LmZyb20ob2JqKS5tYXAoZGVlcENsb25lUGF0Y2hWYWx1ZSkpO1xuICAgIGNvbnN0IGNsb25lZCA9IE9iamVjdC5jcmVhdGUoZ2V0UHJvdG90eXBlT2Yob2JqKSk7XG4gICAgZm9yIChjb25zdCBrZXkgaW4gb2JqKVxuICAgICAgY2xvbmVkW2tleV0gPSBkZWVwQ2xvbmVQYXRjaFZhbHVlKG9ialtrZXldKTtcbiAgICBpZiAoaGFzKG9iaiwgRFJBRlRBQkxFKSlcbiAgICAgIGNsb25lZFtEUkFGVEFCTEVdID0gb2JqW0RSQUZUQUJMRV07XG4gICAgcmV0dXJuIGNsb25lZDtcbiAgfVxuICBmdW5jdGlvbiBjbG9uZVBhdGNoVmFsdWVJZk5lZWRlZChvYmopIHtcbiAgICBpZiAoaXNEcmFmdChvYmopKSB7XG4gICAgICByZXR1cm4gZGVlcENsb25lUGF0Y2hWYWx1ZShvYmopO1xuICAgIH0gZWxzZVxuICAgICAgcmV0dXJuIG9iajtcbiAgfVxuICBsb2FkUGx1Z2luKFwiUGF0Y2hlc1wiLCB7XG4gICAgYXBwbHlQYXRjaGVzXyxcbiAgICBnZW5lcmF0ZVBhdGNoZXNfLFxuICAgIGdlbmVyYXRlUmVwbGFjZW1lbnRQYXRjaGVzX1xuICB9KTtcbn1cblxuLy8gc3JjL3BsdWdpbnMvbWFwc2V0LnRzXG5mdW5jdGlvbiBlbmFibGVNYXBTZXQoKSB7XG4gIGNsYXNzIERyYWZ0TWFwIGV4dGVuZHMgTWFwIHtcbiAgICBjb25zdHJ1Y3Rvcih0YXJnZXQsIHBhcmVudCkge1xuICAgICAgc3VwZXIoKTtcbiAgICAgIHRoaXNbRFJBRlRfU1RBVEVdID0ge1xuICAgICAgICB0eXBlXzogMiAvKiBNYXAgKi8sXG4gICAgICAgIHBhcmVudF86IHBhcmVudCxcbiAgICAgICAgc2NvcGVfOiBwYXJlbnQgPyBwYXJlbnQuc2NvcGVfIDogZ2V0Q3VycmVudFNjb3BlKCksXG4gICAgICAgIG1vZGlmaWVkXzogZmFsc2UsXG4gICAgICAgIGZpbmFsaXplZF86IGZhbHNlLFxuICAgICAgICBjb3B5Xzogdm9pZCAwLFxuICAgICAgICBhc3NpZ25lZF86IHZvaWQgMCxcbiAgICAgICAgYmFzZV86IHRhcmdldCxcbiAgICAgICAgZHJhZnRfOiB0aGlzLFxuICAgICAgICBpc01hbnVhbF86IGZhbHNlLFxuICAgICAgICByZXZva2VkXzogZmFsc2VcbiAgICAgIH07XG4gICAgfVxuICAgIGdldCBzaXplKCkge1xuICAgICAgcmV0dXJuIGxhdGVzdCh0aGlzW0RSQUZUX1NUQVRFXSkuc2l6ZTtcbiAgICB9XG4gICAgaGFzKGtleSkge1xuICAgICAgcmV0dXJuIGxhdGVzdCh0aGlzW0RSQUZUX1NUQVRFXSkuaGFzKGtleSk7XG4gICAgfVxuICAgIHNldChrZXksIHZhbHVlKSB7XG4gICAgICBjb25zdCBzdGF0ZSA9IHRoaXNbRFJBRlRfU1RBVEVdO1xuICAgICAgYXNzZXJ0VW5yZXZva2VkKHN0YXRlKTtcbiAgICAgIGlmICghbGF0ZXN0KHN0YXRlKS5oYXMoa2V5KSB8fCBsYXRlc3Qoc3RhdGUpLmdldChrZXkpICE9PSB2YWx1ZSkge1xuICAgICAgICBwcmVwYXJlTWFwQ29weShzdGF0ZSk7XG4gICAgICAgIG1hcmtDaGFuZ2VkKHN0YXRlKTtcbiAgICAgICAgc3RhdGUuYXNzaWduZWRfLnNldChrZXksIHRydWUpO1xuICAgICAgICBzdGF0ZS5jb3B5Xy5zZXQoa2V5LCB2YWx1ZSk7XG4gICAgICAgIHN0YXRlLmFzc2lnbmVkXy5zZXQoa2V5LCB0cnVlKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBkZWxldGUoa2V5KSB7XG4gICAgICBpZiAoIXRoaXMuaGFzKGtleSkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgY29uc3Qgc3RhdGUgPSB0aGlzW0RSQUZUX1NUQVRFXTtcbiAgICAgIGFzc2VydFVucmV2b2tlZChzdGF0ZSk7XG4gICAgICBwcmVwYXJlTWFwQ29weShzdGF0ZSk7XG4gICAgICBtYXJrQ2hhbmdlZChzdGF0ZSk7XG4gICAgICBpZiAoc3RhdGUuYmFzZV8uaGFzKGtleSkpIHtcbiAgICAgICAgc3RhdGUuYXNzaWduZWRfLnNldChrZXksIGZhbHNlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHN0YXRlLmFzc2lnbmVkXy5kZWxldGUoa2V5KTtcbiAgICAgIH1cbiAgICAgIHN0YXRlLmNvcHlfLmRlbGV0ZShrZXkpO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGNsZWFyKCkge1xuICAgICAgY29uc3Qgc3RhdGUgPSB0aGlzW0RSQUZUX1NUQVRFXTtcbiAgICAgIGFzc2VydFVucmV2b2tlZChzdGF0ZSk7XG4gICAgICBpZiAobGF0ZXN0KHN0YXRlKS5zaXplKSB7XG4gICAgICAgIHByZXBhcmVNYXBDb3B5KHN0YXRlKTtcbiAgICAgICAgbWFya0NoYW5nZWQoc3RhdGUpO1xuICAgICAgICBzdGF0ZS5hc3NpZ25lZF8gPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICAgICAgICBlYWNoKHN0YXRlLmJhc2VfLCAoa2V5KSA9PiB7XG4gICAgICAgICAgc3RhdGUuYXNzaWduZWRfLnNldChrZXksIGZhbHNlKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHN0YXRlLmNvcHlfLmNsZWFyKCk7XG4gICAgICB9XG4gICAgfVxuICAgIGZvckVhY2goY2IsIHRoaXNBcmcpIHtcbiAgICAgIGNvbnN0IHN0YXRlID0gdGhpc1tEUkFGVF9TVEFURV07XG4gICAgICBsYXRlc3Qoc3RhdGUpLmZvckVhY2goKF92YWx1ZSwga2V5LCBfbWFwKSA9PiB7XG4gICAgICAgIGNiLmNhbGwodGhpc0FyZywgdGhpcy5nZXQoa2V5KSwga2V5LCB0aGlzKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgICBnZXQoa2V5KSB7XG4gICAgICBjb25zdCBzdGF0ZSA9IHRoaXNbRFJBRlRfU1RBVEVdO1xuICAgICAgYXNzZXJ0VW5yZXZva2VkKHN0YXRlKTtcbiAgICAgIGNvbnN0IHZhbHVlID0gbGF0ZXN0KHN0YXRlKS5nZXQoa2V5KTtcbiAgICAgIGlmIChzdGF0ZS5maW5hbGl6ZWRfIHx8ICFpc0RyYWZ0YWJsZSh2YWx1ZSkpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgfVxuICAgICAgaWYgKHZhbHVlICE9PSBzdGF0ZS5iYXNlXy5nZXQoa2V5KSkge1xuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICB9XG4gICAgICBjb25zdCBkcmFmdCA9IGNyZWF0ZVByb3h5KHZhbHVlLCBzdGF0ZSk7XG4gICAgICBwcmVwYXJlTWFwQ29weShzdGF0ZSk7XG4gICAgICBzdGF0ZS5jb3B5Xy5zZXQoa2V5LCBkcmFmdCk7XG4gICAgICByZXR1cm4gZHJhZnQ7XG4gICAgfVxuICAgIGtleXMoKSB7XG4gICAgICByZXR1cm4gbGF0ZXN0KHRoaXNbRFJBRlRfU1RBVEVdKS5rZXlzKCk7XG4gICAgfVxuICAgIHZhbHVlcygpIHtcbiAgICAgIGNvbnN0IGl0ZXJhdG9yID0gdGhpcy5rZXlzKCk7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBbU3ltYm9sLml0ZXJhdG9yXTogKCkgPT4gdGhpcy52YWx1ZXMoKSxcbiAgICAgICAgbmV4dDogKCkgPT4ge1xuICAgICAgICAgIGNvbnN0IHIgPSBpdGVyYXRvci5uZXh0KCk7XG4gICAgICAgICAgaWYgKHIuZG9uZSlcbiAgICAgICAgICAgIHJldHVybiByO1xuICAgICAgICAgIGNvbnN0IHZhbHVlID0gdGhpcy5nZXQoci52YWx1ZSk7XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGRvbmU6IGZhbHNlLFxuICAgICAgICAgICAgdmFsdWVcbiAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICB9O1xuICAgIH1cbiAgICBlbnRyaWVzKCkge1xuICAgICAgY29uc3QgaXRlcmF0b3IgPSB0aGlzLmtleXMoKTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIFtTeW1ib2wuaXRlcmF0b3JdOiAoKSA9PiB0aGlzLmVudHJpZXMoKSxcbiAgICAgICAgbmV4dDogKCkgPT4ge1xuICAgICAgICAgIGNvbnN0IHIgPSBpdGVyYXRvci5uZXh0KCk7XG4gICAgICAgICAgaWYgKHIuZG9uZSlcbiAgICAgICAgICAgIHJldHVybiByO1xuICAgICAgICAgIGNvbnN0IHZhbHVlID0gdGhpcy5nZXQoci52YWx1ZSk7XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGRvbmU6IGZhbHNlLFxuICAgICAgICAgICAgdmFsdWU6IFtyLnZhbHVlLCB2YWx1ZV1cbiAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICB9O1xuICAgIH1cbiAgICBbKERSQUZUX1NUQVRFLCBTeW1ib2wuaXRlcmF0b3IpXSgpIHtcbiAgICAgIHJldHVybiB0aGlzLmVudHJpZXMoKTtcbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gcHJveHlNYXBfKHRhcmdldCwgcGFyZW50KSB7XG4gICAgcmV0dXJuIG5ldyBEcmFmdE1hcCh0YXJnZXQsIHBhcmVudCk7XG4gIH1cbiAgZnVuY3Rpb24gcHJlcGFyZU1hcENvcHkoc3RhdGUpIHtcbiAgICBpZiAoIXN0YXRlLmNvcHlfKSB7XG4gICAgICBzdGF0ZS5hc3NpZ25lZF8gPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICAgICAgc3RhdGUuY29weV8gPSBuZXcgTWFwKHN0YXRlLmJhc2VfKTtcbiAgICB9XG4gIH1cbiAgY2xhc3MgRHJhZnRTZXQgZXh0ZW5kcyBTZXQge1xuICAgIGNvbnN0cnVjdG9yKHRhcmdldCwgcGFyZW50KSB7XG4gICAgICBzdXBlcigpO1xuICAgICAgdGhpc1tEUkFGVF9TVEFURV0gPSB7XG4gICAgICAgIHR5cGVfOiAzIC8qIFNldCAqLyxcbiAgICAgICAgcGFyZW50XzogcGFyZW50LFxuICAgICAgICBzY29wZV86IHBhcmVudCA/IHBhcmVudC5zY29wZV8gOiBnZXRDdXJyZW50U2NvcGUoKSxcbiAgICAgICAgbW9kaWZpZWRfOiBmYWxzZSxcbiAgICAgICAgZmluYWxpemVkXzogZmFsc2UsXG4gICAgICAgIGNvcHlfOiB2b2lkIDAsXG4gICAgICAgIGJhc2VfOiB0YXJnZXQsXG4gICAgICAgIGRyYWZ0XzogdGhpcyxcbiAgICAgICAgZHJhZnRzXzogLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKSxcbiAgICAgICAgcmV2b2tlZF86IGZhbHNlLFxuICAgICAgICBpc01hbnVhbF86IGZhbHNlXG4gICAgICB9O1xuICAgIH1cbiAgICBnZXQgc2l6ZSgpIHtcbiAgICAgIHJldHVybiBsYXRlc3QodGhpc1tEUkFGVF9TVEFURV0pLnNpemU7XG4gICAgfVxuICAgIGhhcyh2YWx1ZSkge1xuICAgICAgY29uc3Qgc3RhdGUgPSB0aGlzW0RSQUZUX1NUQVRFXTtcbiAgICAgIGFzc2VydFVucmV2b2tlZChzdGF0ZSk7XG4gICAgICBpZiAoIXN0YXRlLmNvcHlfKSB7XG4gICAgICAgIHJldHVybiBzdGF0ZS5iYXNlXy5oYXModmFsdWUpO1xuICAgICAgfVxuICAgICAgaWYgKHN0YXRlLmNvcHlfLmhhcyh2YWx1ZSkpXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgaWYgKHN0YXRlLmRyYWZ0c18uaGFzKHZhbHVlKSAmJiBzdGF0ZS5jb3B5Xy5oYXMoc3RhdGUuZHJhZnRzXy5nZXQodmFsdWUpKSlcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGFkZCh2YWx1ZSkge1xuICAgICAgY29uc3Qgc3RhdGUgPSB0aGlzW0RSQUZUX1NUQVRFXTtcbiAgICAgIGFzc2VydFVucmV2b2tlZChzdGF0ZSk7XG4gICAgICBpZiAoIXRoaXMuaGFzKHZhbHVlKSkge1xuICAgICAgICBwcmVwYXJlU2V0Q29weShzdGF0ZSk7XG4gICAgICAgIG1hcmtDaGFuZ2VkKHN0YXRlKTtcbiAgICAgICAgc3RhdGUuY29weV8uYWRkKHZhbHVlKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBkZWxldGUodmFsdWUpIHtcbiAgICAgIGlmICghdGhpcy5oYXModmFsdWUpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHN0YXRlID0gdGhpc1tEUkFGVF9TVEFURV07XG4gICAgICBhc3NlcnRVbnJldm9rZWQoc3RhdGUpO1xuICAgICAgcHJlcGFyZVNldENvcHkoc3RhdGUpO1xuICAgICAgbWFya0NoYW5nZWQoc3RhdGUpO1xuICAgICAgcmV0dXJuIHN0YXRlLmNvcHlfLmRlbGV0ZSh2YWx1ZSkgfHwgKHN0YXRlLmRyYWZ0c18uaGFzKHZhbHVlKSA/IHN0YXRlLmNvcHlfLmRlbGV0ZShzdGF0ZS5kcmFmdHNfLmdldCh2YWx1ZSkpIDogKFxuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgICAgICBmYWxzZVxuICAgICAgKSk7XG4gICAgfVxuICAgIGNsZWFyKCkge1xuICAgICAgY29uc3Qgc3RhdGUgPSB0aGlzW0RSQUZUX1NUQVRFXTtcbiAgICAgIGFzc2VydFVucmV2b2tlZChzdGF0ZSk7XG4gICAgICBpZiAobGF0ZXN0KHN0YXRlKS5zaXplKSB7XG4gICAgICAgIHByZXBhcmVTZXRDb3B5KHN0YXRlKTtcbiAgICAgICAgbWFya0NoYW5nZWQoc3RhdGUpO1xuICAgICAgICBzdGF0ZS5jb3B5Xy5jbGVhcigpO1xuICAgICAgfVxuICAgIH1cbiAgICB2YWx1ZXMoKSB7XG4gICAgICBjb25zdCBzdGF0ZSA9IHRoaXNbRFJBRlRfU1RBVEVdO1xuICAgICAgYXNzZXJ0VW5yZXZva2VkKHN0YXRlKTtcbiAgICAgIHByZXBhcmVTZXRDb3B5KHN0YXRlKTtcbiAgICAgIHJldHVybiBzdGF0ZS5jb3B5Xy52YWx1ZXMoKTtcbiAgICB9XG4gICAgZW50cmllcygpIHtcbiAgICAgIGNvbnN0IHN0YXRlID0gdGhpc1tEUkFGVF9TVEFURV07XG4gICAgICBhc3NlcnRVbnJldm9rZWQoc3RhdGUpO1xuICAgICAgcHJlcGFyZVNldENvcHkoc3RhdGUpO1xuICAgICAgcmV0dXJuIHN0YXRlLmNvcHlfLmVudHJpZXMoKTtcbiAgICB9XG4gICAga2V5cygpIHtcbiAgICAgIHJldHVybiB0aGlzLnZhbHVlcygpO1xuICAgIH1cbiAgICBbKERSQUZUX1NUQVRFLCBTeW1ib2wuaXRlcmF0b3IpXSgpIHtcbiAgICAgIHJldHVybiB0aGlzLnZhbHVlcygpO1xuICAgIH1cbiAgICBmb3JFYWNoKGNiLCB0aGlzQXJnKSB7XG4gICAgICBjb25zdCBpdGVyYXRvciA9IHRoaXMudmFsdWVzKCk7XG4gICAgICBsZXQgcmVzdWx0ID0gaXRlcmF0b3IubmV4dCgpO1xuICAgICAgd2hpbGUgKCFyZXN1bHQuZG9uZSkge1xuICAgICAgICBjYi5jYWxsKHRoaXNBcmcsIHJlc3VsdC52YWx1ZSwgcmVzdWx0LnZhbHVlLCB0aGlzKTtcbiAgICAgICAgcmVzdWx0ID0gaXRlcmF0b3IubmV4dCgpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBmdW5jdGlvbiBwcm94eVNldF8odGFyZ2V0LCBwYXJlbnQpIHtcbiAgICByZXR1cm4gbmV3IERyYWZ0U2V0KHRhcmdldCwgcGFyZW50KTtcbiAgfVxuICBmdW5jdGlvbiBwcmVwYXJlU2V0Q29weShzdGF0ZSkge1xuICAgIGlmICghc3RhdGUuY29weV8pIHtcbiAgICAgIHN0YXRlLmNvcHlfID0gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoKTtcbiAgICAgIHN0YXRlLmJhc2VfLmZvckVhY2goKHZhbHVlKSA9PiB7XG4gICAgICAgIGlmIChpc0RyYWZ0YWJsZSh2YWx1ZSkpIHtcbiAgICAgICAgICBjb25zdCBkcmFmdCA9IGNyZWF0ZVByb3h5KHZhbHVlLCBzdGF0ZSk7XG4gICAgICAgICAgc3RhdGUuZHJhZnRzXy5zZXQodmFsdWUsIGRyYWZ0KTtcbiAgICAgICAgICBzdGF0ZS5jb3B5Xy5hZGQoZHJhZnQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHN0YXRlLmNvcHlfLmFkZCh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuICBmdW5jdGlvbiBhc3NlcnRVbnJldm9rZWQoc3RhdGUpIHtcbiAgICBpZiAoc3RhdGUucmV2b2tlZF8pXG4gICAgICBkaWUoMywgSlNPTi5zdHJpbmdpZnkobGF0ZXN0KHN0YXRlKSkpO1xuICB9XG4gIGxvYWRQbHVnaW4oXCJNYXBTZXRcIiwgeyBwcm94eU1hcF8sIHByb3h5U2V0XyB9KTtcbn1cblxuLy8gc3JjL2ltbWVyLnRzXG52YXIgaW1tZXIgPSBuZXcgSW1tZXIyKCk7XG52YXIgcHJvZHVjZSA9IGltbWVyLnByb2R1Y2U7XG52YXIgcHJvZHVjZVdpdGhQYXRjaGVzID0gLyogQF9fUFVSRV9fICovIGltbWVyLnByb2R1Y2VXaXRoUGF0Y2hlcy5iaW5kKFxuICBpbW1lclxuKTtcbnZhciBzZXRBdXRvRnJlZXplID0gLyogQF9fUFVSRV9fICovIGltbWVyLnNldEF1dG9GcmVlemUuYmluZChpbW1lcik7XG52YXIgc2V0VXNlU3RyaWN0U2hhbGxvd0NvcHkgPSAvKiBAX19QVVJFX18gKi8gaW1tZXIuc2V0VXNlU3RyaWN0U2hhbGxvd0NvcHkuYmluZChcbiAgaW1tZXJcbik7XG52YXIgc2V0VXNlU3RyaWN0SXRlcmF0aW9uID0gLyogQF9fUFVSRV9fICovIGltbWVyLnNldFVzZVN0cmljdEl0ZXJhdGlvbi5iaW5kKFxuICBpbW1lclxuKTtcbnZhciBhcHBseVBhdGNoZXMgPSAvKiBAX19QVVJFX18gKi8gaW1tZXIuYXBwbHlQYXRjaGVzLmJpbmQoaW1tZXIpO1xudmFyIGNyZWF0ZURyYWZ0ID0gLyogQF9fUFVSRV9fICovIGltbWVyLmNyZWF0ZURyYWZ0LmJpbmQoaW1tZXIpO1xudmFyIGZpbmlzaERyYWZ0ID0gLyogQF9fUFVSRV9fICovIGltbWVyLmZpbmlzaERyYWZ0LmJpbmQoaW1tZXIpO1xuZnVuY3Rpb24gY2FzdERyYWZ0KHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZTtcbn1cbmZ1bmN0aW9uIGNhc3RJbW11dGFibGUodmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlO1xufVxuZXhwb3J0IHtcbiAgSW1tZXIyIGFzIEltbWVyLFxuICBhcHBseVBhdGNoZXMsXG4gIGNhc3REcmFmdCxcbiAgY2FzdEltbXV0YWJsZSxcbiAgY3JlYXRlRHJhZnQsXG4gIGN1cnJlbnQsXG4gIGVuYWJsZU1hcFNldCxcbiAgZW5hYmxlUGF0Y2hlcyxcbiAgZmluaXNoRHJhZnQsXG4gIGZyZWV6ZSxcbiAgRFJBRlRBQkxFIGFzIGltbWVyYWJsZSxcbiAgaXNEcmFmdCxcbiAgaXNEcmFmdGFibGUsXG4gIE5PVEhJTkcgYXMgbm90aGluZyxcbiAgb3JpZ2luYWwsXG4gIHByb2R1Y2UsXG4gIHByb2R1Y2VXaXRoUGF0Y2hlcyxcbiAgc2V0QXV0b0ZyZWV6ZSxcbiAgc2V0VXNlU3RyaWN0SXRlcmF0aW9uLFxuICBzZXRVc2VTdHJpY3RTaGFsbG93Q29weVxufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWltbWVyLm1qcy5tYXAiXSwibmFtZXMiOlsiTk9USElORyIsIlN5bWJvbCIsImZvciIsIkRSQUZUQUJMRSIsIkRSQUZUX1NUQVRFIiwiZXJyb3JzIiwicHJvY2VzcyIsInBsdWdpbiIsInRoaW5nIiwiZGF0YSIsImRpZSIsImVycm9yIiwiYXJncyIsImUiLCJtc2ciLCJhcHBseSIsIkVycm9yIiwiZ2V0UHJvdG90eXBlT2YiLCJPYmplY3QiLCJpc0RyYWZ0IiwidmFsdWUiLCJpc0RyYWZ0YWJsZSIsImlzUGxhaW5PYmplY3QiLCJBcnJheSIsImlzQXJyYXkiLCJjb25zdHJ1Y3RvciIsImlzTWFwIiwiaXNTZXQiLCJvYmplY3RDdG9yU3RyaW5nIiwicHJvdG90eXBlIiwidG9TdHJpbmciLCJjYWNoZWRDdG9yU3RyaW5ncyIsIldlYWtNYXAiLCJwcm90byIsIkN0b3IiLCJoYXNPd25Qcm9wZXJ0eSIsImNhbGwiLCJjdG9yU3RyaW5nIiwiZ2V0IiwiRnVuY3Rpb24iLCJzZXQiLCJvcmlnaW5hbCIsImJhc2VfIiwiZWFjaCIsIm9iaiIsIml0ZXIiLCJzdHJpY3QiLCJnZXRBcmNodHlwZSIsImtleXMiLCJSZWZsZWN0Iiwib3duS2V5cyIsImZvckVhY2giLCJrZXkiLCJlbnRyeSIsImluZGV4Iiwic3RhdGUiLCJ0eXBlXyIsImhhcyIsInByb3AiLCJwcm9wT3JPbGRWYWx1ZSIsInQiLCJhZGQiLCJpcyIsIngiLCJ5IiwidGFyZ2V0IiwiTWFwIiwiU2V0IiwibGF0ZXN0IiwiY29weV8iLCJzaGFsbG93Q29weSIsImJhc2UiLCJzbGljZSIsImlzUGxhaW4iLCJkZXNjcmlwdG9ycyIsImdldE93blByb3BlcnR5RGVzY3JpcHRvcnMiLCJpIiwibGVuZ3RoIiwiZGVzYyIsIndyaXRhYmxlIiwiY29uZmlndXJhYmxlIiwiZW51bWVyYWJsZSIsImNyZWF0ZSIsImFzc2lnbiIsImZyZWV6ZSIsImRlZXAiLCJpc0Zyb3plbiIsImRlZmluZVByb3BlcnRpZXMiLCJkb250TXV0YXRlTWV0aG9kT3ZlcnJpZGUiLCJjbGVhciIsImRlbGV0ZSIsInZhbHVlcyIsImRvbnRNdXRhdGVGcm96ZW5Db2xsZWN0aW9ucyIsInBsdWdpbnMiLCJnZXRQbHVnaW4iLCJwbHVnaW5LZXkiLCJsb2FkUGx1Z2luIiwiaW1wbGVtZW50YXRpb24iLCJjdXJyZW50U2NvcGUiLCJnZXRDdXJyZW50U2NvcGUiLCJjcmVhdGVTY29wZSIsInBhcmVudF8iLCJpbW1lcl8iLCJkcmFmdHNfIiwiY2FuQXV0b0ZyZWV6ZV8iLCJ1bmZpbmFsaXplZERyYWZ0c18iLCJ1c2VQYXRjaGVzSW5TY29wZSIsInNjb3BlIiwicGF0Y2hMaXN0ZW5lciIsInBhdGNoZXNfIiwiaW52ZXJzZVBhdGNoZXNfIiwicGF0Y2hMaXN0ZW5lcl8iLCJyZXZva2VTY29wZSIsImxlYXZlU2NvcGUiLCJyZXZva2VEcmFmdCIsImVudGVyU2NvcGUiLCJpbW1lcjIiLCJkcmFmdCIsInJldm9rZV8iLCJyZXZva2VkXyIsInByb2Nlc3NSZXN1bHQiLCJyZXN1bHQiLCJiYXNlRHJhZnQiLCJpc1JlcGxhY2VkIiwibW9kaWZpZWRfIiwiZmluYWxpemUiLCJtYXliZUZyZWV6ZSIsImdlbmVyYXRlUmVwbGFjZW1lbnRQYXRjaGVzXyIsInJvb3RTY29wZSIsInBhdGgiLCJ1c2VTdHJpY3RJdGVyYXRpb24iLCJzaG91bGRVc2VTdHJpY3RJdGVyYXRpb24iLCJjaGlsZFZhbHVlIiwiZmluYWxpemVQcm9wZXJ0eSIsInNjb3BlXyIsImZpbmFsaXplZF8iLCJyZXN1bHRFYWNoIiwiaXNTZXQyIiwiZ2VuZXJhdGVQYXRjaGVzXyIsInBhcmVudFN0YXRlIiwidGFyZ2V0T2JqZWN0Iiwicm9vdFBhdGgiLCJ0YXJnZXRJc1NldCIsImNoaWxkSXNGcm96ZW4iLCJhc3NpZ25lZF8iLCJjb25jYXQiLCJyZXMiLCJhdXRvRnJlZXplXyIsInByb3BlcnR5SXNFbnVtZXJhYmxlIiwiY3JlYXRlUHJveHlQcm94eSIsInBhcmVudCIsImRyYWZ0XyIsImlzTWFudWFsXyIsInRyYXBzIiwib2JqZWN0VHJhcHMiLCJhcnJheVRyYXBzIiwicmV2b2tlIiwicHJveHkiLCJQcm94eSIsInJldm9jYWJsZSIsInNvdXJjZSIsInJlYWRQcm9wRnJvbVByb3RvIiwicGVlayIsInByZXBhcmVDb3B5IiwiY3JlYXRlUHJveHkiLCJnZXREZXNjcmlwdG9yRnJvbVByb3RvIiwiY3VycmVudDIiLCJjdXJyZW50U3RhdGUiLCJtYXJrQ2hhbmdlZCIsIk51bWJlciIsImlzTmFOIiwiZGVsZXRlUHJvcGVydHkiLCJnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IiLCJvd25lciIsImRlZmluZVByb3BlcnR5Iiwic2V0UHJvdG90eXBlT2YiLCJmbiIsImFyZ3VtZW50cyIsInBhcnNlSW50IiwidXNlU3RyaWN0U2hhbGxvd0NvcHlfIiwiSW1tZXIyIiwiY29uZmlnIiwidXNlU3RyaWN0SXRlcmF0aW9uXyIsInByb2R1Y2UiLCJyZWNpcGUiLCJkZWZhdWx0QmFzZSIsInNlbGYiLCJjdXJyaWVkUHJvZHVjZSIsImJhc2UyIiwiaGFzRXJyb3IiLCJwIiwiaXAiLCJwcm9kdWNlV2l0aFBhdGNoZXMiLCJwYXRjaGVzIiwiaW52ZXJzZVBhdGNoZXMiLCJhdXRvRnJlZXplIiwic2V0QXV0b0ZyZWV6ZSIsInVzZVN0cmljdFNoYWxsb3dDb3B5Iiwic2V0VXNlU3RyaWN0U2hhbGxvd0NvcHkiLCJzZXRVc2VTdHJpY3RJdGVyYXRpb24iLCJjcmVhdGVEcmFmdCIsImN1cnJlbnQiLCJmaW5pc2hEcmFmdCIsImFwcGx5UGF0Y2hlcyIsInBhdGNoIiwib3AiLCJhcHBseVBhdGNoZXNJbXBsIiwiYXBwbHlQYXRjaGVzXyIsInByb3h5TWFwXyIsInByb3h5U2V0XyIsInB1c2giLCJjdXJyZW50SW1wbCIsImNvcHkiLCJlbmFibGVQYXRjaGVzIiwiZXJyb3JPZmZzZXQiLCJSRVBMQUNFIiwiQUREIiwiUkVNT1ZFIiwiYmFzZVBhdGgiLCJnZW5lcmF0ZVBhdGNoZXNGcm9tQXNzaWduZWQiLCJnZW5lcmF0ZUFycmF5UGF0Y2hlcyIsImdlbmVyYXRlU2V0UGF0Y2hlcyIsImNsb25lUGF0Y2hWYWx1ZUlmTmVlZGVkIiwiYXNzaWduZWRWYWx1ZSIsIm9yaWdWYWx1ZSIsInVuc2hpZnQiLCJiYXNlVmFsdWUiLCJyZXBsYWNlbWVudCIsInBhcmVudFR5cGUiLCJqb2luIiwidHlwZSIsImRlZXBDbG9uZVBhdGNoVmFsdWUiLCJzcGxpY2UiLCJtYXAiLCJmcm9tIiwiZW50cmllcyIsImsiLCJ2IiwiY2xvbmVkIiwiZW5hYmxlTWFwU2V0IiwiRHJhZnRNYXAiLCJzaXplIiwiYXNzZXJ0VW5yZXZva2VkIiwicHJlcGFyZU1hcENvcHkiLCJjYiIsInRoaXNBcmciLCJfdmFsdWUiLCJfbWFwIiwiaXRlcmF0b3IiLCJuZXh0IiwiciIsImRvbmUiLCJEcmFmdFNldCIsInByZXBhcmVTZXRDb3B5IiwiSlNPTiIsInN0cmluZ2lmeSIsImltbWVyIiwiYmluZCIsImNhc3REcmFmdCIsImNhc3RJbW11dGFibGUiLCJJbW1lciIsImltbWVyYWJsZSIsIm5vdGhpbmciXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/immer/dist/immer.mjs\n");

/***/ })

};
;